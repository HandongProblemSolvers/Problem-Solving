- **내가 이해한 문제내용**
  - 네트워크를 연결하는데, K개의 페어를 만들 것이다. 이때, 각 노드는 2개이상의 연결이 없다.
  - 이때 전체의 최소 연결 길이를 구하여라.
- **접근 방식**
  - 일단 문제를 시작할때, N의 크기를 보고 O(NlogN)이라는 것은 감을 잡았다.
  - 일단, DP로 풀리는지에 대해서 생각했는데 기본적으로 떠오르는 2차원 형태의 점화식 형태는 메모리 부족과 시간초과로 힘들 것 같다는 생각을 했다. O(N^2)
  - 이 뒤에 예제를 통해 패턴을 찾아보았다.
  - 여기서 중첩 되는 경우를 제거하기 위한 형태를 생각해야 하는데, 보통 하나가 연결되었을 때, 주변을 연결하기 위해서는 자신의 네트워크를 끈어야 한다는 점을 주목했다.
  - 먼저 우리는 최소 전체 길이 이며, K개의 페어를 찾아야 한다. 이때, 처음에 각 노드가 연결되지 않은 상태에서는 당연히 그 중에 제일 작은 것을 선택할 것은 자명하다.
  - 이 위에서 생각한 연결된 주변이 연결 되기 위한 조건을 착안하여, 좌우가 연결 될 경우 여기서 필요로 하게 되는 전체 길이는 `(좌우 연결된 길이) - (원래 연결된 길이)`가 되며 전체 연결 페어수가 1개가 증가하는 것을 발견했다.
  - 이 전제에서 이 `(좌우 연결된 길이) - (원래 연결된 길이)` 또한 하나의 페어를 추가하기 위한 cost로 볼 수 있다.... 허허... 이해가려나?
  - 일단 여기까지는 했다. 이 뒤에 priority_queue를 이용하여 각 구간의 최소 값을 판별하고 visited를 통해서 좌우의 합쳐졌을 경우 이를 무시하는 조건을 만들었다.
  - 여기서 priority_queue에 요소가 합쳐진 뒤에 left와 right의 정보를 같이 담도록 <dist, <left, right>> 형태의 데이터 구조를 생각했는데, 적합하지 못하다는 것을 인지했다. ㅠㅠ...
  - 결국 합쳐진 뒤에 이 요소의 left와 right가 어디인지에 대해 처리하는 방법을 생각하지 못했다... ㅠㅠㅠ
  - 결국 답을 보게 되었고, 합치는 방법을 처리하는 코드를 보고 감탄했다 ㄷㄷ...
  - 알고리즘은 이와 같다. left와 right 배열을 할당하여, 현재의 idx가 가지는 left boundary와 right boundary를 저장한다. 초기 left = idx-1, right = idx+1 (결국 좌우)
  - 여기서 요소를 priority에서 최소값을 끄내서 좌우에 있는 구간을 합친다.
  - 이때, left[idx]와 right[idx]를 이용해서 좌우 idx에 접근한다. 우리는 합치기 위해서는 left[idx]가 가리키는 Lidx에 left를 현재 idx의 left[idx]로 업데이트 해야한다.(현재 요소의 왼쪽 구간의 왼쪽을 자기 자신의 왼쪽으로 업데이트) 또한 right에 대해서도 right[idx] = right[right[idx]]를 이용해서 오른쪽 도 업데이트 한다. (현제 인덱스 좌우 합침.)
  - 여기서 한가지를 더해줘야 하는데, 현재 idx에 대해서는 left와 right 범위를 알 수 있지만, 밖에서 현재 idx를 합치려고 들때는 자신의 양끝 boundary idx에 접근해서 이를 확인하려고 하기 때문에 이를 해결해 줘야한다.
  - 예를 들면 현재 합친 뒤에 이 요소를 오른쪽이 자신으로 합치려고 할때, 현재 right boundary가 가리키는 left 값을 이용하여 자신의 left이 어딘지 알려줘야 한다. 이 때문에 left[right[idx]]=idx 를 통해서 나중에 현재 left[idx]의 접근 하여 left[left[idx]]에 접근 가능하도록 해준다.
  - 결국 아름다운 코드는 4줄이었다 아래와 같다.
  - left[idx] = left[left[idx]]
  - right[idx] = right[right[idx]]
  - left[right[idx]] = idx
  - right[left[idx]] = idx
- **어려웠던 점**
  - 역시 KOOOOOSAGA... 정말 저어엉말 재미나서 미치는 문제였다.
  - 그리디 형태로 이를 치환하는데 하루 걸리고... 이를 구현하는 형태에서 priority_queue 이용한 binary search 형태까지는 치환했지만, union find의 find에서 사용한 compress 알고리즘 꼴을 이렇게 이용해서 좌우를 합치는 형태를 한다는 것이 기가막히고 코가막히고 `숨이막힌다`... 
  - 다음에 이런 형태로 좌우를 합치는 형태를 사용할때 정말 애용할 것이다. (솔직히 예전에 한번 조오금 비슷한 형태를 본거 같은데 `나는 바보다` ㅎㅎ)
- **복잡도**
  $(var): n(node)
  - 시간복잡도: `O(NlogN)`
  - 공간복잡도: dp에 사용한 메모리 `O(N)`
