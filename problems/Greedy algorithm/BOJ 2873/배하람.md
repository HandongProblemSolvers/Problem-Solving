- **내가 이해한 문제내용**
  - 2차원 배열이 주어지고 각 칸에 "기쁨"값이 양수로 주어질 때 롤러코스터가 이동하는 경로가 최대가 되도록 L,U,R,D로 그 경로를 나타내시오.
- **접근 방식**
  - 처음엔 DFS인줄 알고 모든 경우를 계산하려 했지만 경로추적을 할 때 메모리초과가 발생했고 각 칸이 양수라는 점 때문에 굳이 DFS를 쓸 이유가 없었다.
  - R과 C의 값이 짝수인지 홀수인지에 따라 구분하는 것 까지는 했지만 둘 다 짝수일 경우의 구현이 상당히 복잡해서 계속 고민하다 해답을 봤다.
- **어려웠던 점**
  - 중요한 관찰은 행과 열의 인덱스 값의 합이 홀수인 경우 하나만을 제외하고 모두 지날 수 있다는 것이다. 이것은 체스판으로 생각해보면 이해할 수 있다. [백준님 풀이](https://www.slideshare.net/Baekjoon/baekjoon-online-judge-2873)가 굉장히 깔끔하니 여기를 참고하자.
  - 이제 합이 홀수가 되는 모든 지점들 중에 최솟값을 구하고 그 최솟값을 제외한 모든 나머지 값을 지나는 경로를 구하면 된다.
  - 하지만 이걸 이해한다 해도 구현이 굉장히 까다롭기 때문에 풀이를 보기전에 일반화하려고 했지만 도저히 안되겠다 싶어 풀이를 본 것이고 풀이에선 지날 수 없는 칸이 없는 행들과 열들에 대해서 지워나가는 방식을 사용한다.
  - 즉, 자명한 경로에 대해선 계속해서 지워나가면서 마지막으로 지날 수 없는 칸을 포함한 2X2 배열만 남겨서 오른쪽 아래로 이동할 것인지, 아래 오른쪽으로 이동할 것인지를 결정하는 방식을 사용한다.
  - 처음엔 코드가 더럽다고 생각했지만 공부하면서 이런 문제도 상당히 중요하다는 것을 깨달았는데, 그 이유는 구현이 까다롭기 때문에 구현을 연습함에 있어서 도움이 된다고 생각한다.
- **복잡도**
  - 지날 수 없는 칸들 중 최솟값을 찾는 `O(RC)`보다 더 시간을 많이 소모하는 연산은 없기 때문에 최종 연산이 `O(RC)`이다.
