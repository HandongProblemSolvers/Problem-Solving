- ### 내가 이해한 문제내용  
  - 나무 그루터기의 개수 N(2<=N<=4000), 오솔길의 개수 M(1<=M<=100000)가 주어지고, M개의 줄에 a, b, d(1<=a,b<=N, 1<=d<=100000)가 주어질 때,  
      
    (1) 그루터기의 번호는 (1 ~ N)이다.  
    (2) 늑대는 처음에는 여우의 2배 속력으로 이동하고 다음에는 1/2의 속력, 그 다음에는 2배속력...으로 이동한다.  
       
    위의 조건을 만족할 때, 여우가 먼저 도착할 수 있는 그루터기의 개수 구하기  
    
- ### 접근방식  
  - 다익스트라 알고리즘 : 한 개의 노드에서 다른 모든 노드로의 최단거리를 구하는 알고리즘  
     
    (1) 인접매트릭스 a[i][j]생성  
    (2) 시작 노드로의 거리를 0으로 초기화  
    (3) 방문하지 않은 노드 중 가장 거리가 짧은 노드 구함  
    (4) 구한 노드와 인접한 노드의 거리 업데이트  
        dist[i] = min(dist[curr] + a[curr][i], dist[i])  
    (5) (3) ~ (4) 를 모든 노드를 방문할 때까지 반복  
    
    늑대가 이동하는 그래프의 인접매트릭스 : 빠르게 했을 때 도착하는 노드번호를 2n, 느리게 이동했을 때 도착하는 노드번호를 2n+1로 하는 매트릭스  
    
  - 문제  
    (1) a, b, d를 각각 이차원 배열에 저장  
    (2) 저장한 값으로 인접매트릭스 생성  
    (2) 다익스트라 알고리즘으로 최단거리 구함  
    (3) 저장한 값으로 새로운 인접매트릭스 생성  
    (4) 다익스트라 알고리즘으로 최단거리 구함  
    (5) 첫번째로 구한 최단거리의 값이 더 작은 노드의 개수 구함  
    (6) 구한 노드의 개수 출력  
   
- ### 어려웠던 점    
  - 빨라졌다가 느려지는 이동을 하는 그래프를 만드는 방법을 생각하기 어려웠다.  
    반례를 찾지 모하였다.  

- ### 복잡도  
  - 시간복잡도: O(M + N^2)  
    (2) O(M) + (2) O(2N^2) + (3) O(M) + (4) O(2N^2) + (5) O(N) = O(M + N^2)  
     
