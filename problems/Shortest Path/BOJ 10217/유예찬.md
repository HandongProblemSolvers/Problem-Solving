- **내가 이해한 문제내용**
  - 도시 1부터 N까지 M의 비용 내에서 비행기를 타고 최단시간에 도착하고 싶다.
  - 최단 시간을 출력해라. 가능하지 않으면 "Poor KCM"출력해라.

- **접근 방식**
  - 문제를 너무 만만하게 보았다. 최단거리라는 측면에서 다익스트라로 접근했다.ㄷ?
  - 다익스트라는 좋은 접근이 아니었다. 복귀해보자.
    - 다익스트라는 최단 경로이긴 하지만, 비용이라는 제한 조건 상에서 다익스트라는 올바르지 않다.
    - 다익스트라의 Priority_queue 인 힙의 판단 조건이 의미가 없게 되며, 최단 경로를 보장하지 않는다.
    - 고로 우리는 다익스트라를 통해서 현재 까지의 경로가 **"M보다 비용이 적으며 최단 경로"** 임을 보장 할 수 없다.
  - 이제 우리는 다익스트라 이외의 다른 부분을 생각해야하는데, N이 100이며 비용이 10000정도인 부분의 관점을 바꿨다.
  - 여기서 NM=100만 정도로 메모리의 저장 가능하다. 이 의미는 Node와 Cost에 대한 상태를 dp의 Memoization이 가능하다는 것이다.
  - 이제 dp(current node)(current cost)으로 이 dp를 정의한다.
    - current node: 현재 탐색중인 노드
    - current cost: 1부터 현재까지 사용한 cost 값
    - dp의 저장되는 값은 **current node부터 cost<=M이 만족하는 N까지의 최단시간 값**
    - 불가능한 경우 1e9의 값을 사용함 (아무리 길어봤자. delay * K = 1e4 * 1e4 = 1e8 < 1e9)
    - 자 그래 1e9이면 current 부터 N까지 못간당~
  - 위에 dp의 형태를 최적화 하게 접근하려면 cost가 적은 순서대로 접근하고 같은 경우 delay 적은 형태로 dp를 사용함.
  - 위를 위해 각 node의 Vertex를 Sorting함 최적화(1372ms > 1044ms)

- **어려웠던 점**
  - 너무 생각 없이 다익스트라를 사용했다는 것이 정말 바보다.
  - dfs 형태에서 메모리 100만 정의가 정의되니 점화식짜는건 단순했다.

- **복잡도**
  $(var):
  - 시간복잡도: `O(NMK)`
  - 공간복잡도: `O(NM+K)`
