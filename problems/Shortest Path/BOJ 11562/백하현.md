- ### 내가 이해한 문제내용  
  - 건물의 수 n(1<=n<=250), 길의 수 m(1<=m<=nx(n-1)/2)과 m줄에 걸쳐 u,v,b (1<=u<=n, 1<=v<=n, u != v, b=0 또는 1)이 주어지고 질문의 수 k(1<=k<=30000), k줄에 걸쳐 출발지점 s(1<=s<=n), 도착지점 e(1<=e<=n)가 주어질 때,     
      
    (1) b=0이면 u에서 v로 가는 일방향 통행이다.  
    (2) b=1이면 u에서 v로 가는 양방향 통행이다.  
    (3) 모든 길을 양방향으로 바꾸더라도 가지 못하는 건물은 없다.  
      
    위의 조건을 만족할때, 각 질문에 대해 출발지에서 도착지로 가기 위해 양방향으로 바꾸어야 하는 길의 최소 개수 구하기  
    
- ### 접근방식  
  - 플로이드-와샬 알고리즘  
      
    한 정점에서 다른 모든 정점으로 이동할 때의 최소거리: 다익스트라(음수 가중치 불가), 벨만-포드(음수 가중치 가능)  
    다른 모든 정점에서 다른 모든 정점으로 이동할 때의 최소거리: 플로이드-와샬(음수 가중치 가능)  
        
    dp[i][j] (i+1번째 노드에서 j+1번째 노드까지 가는데 걸리는 최소거리)  
      
      
    초기화 과정  
    dp[i][j]에 인접행렬의 값을 넣어줌 (i==j일 때 0, 연결되지 않았을 때 INF(무한))  
    
    DP과정  
    dp[i][j] = min(dp[i][k] + dp[k][j], dp[i][j]) (k: i+1번째 노드와 j+1번째 노드 사이에 거치는 노드번호-1)    
    nxnxn번 반복  
      
  - 문제    
    (1) 그래프의 간선을 이차원 배열에 저장  
    (2-1) 간선이 양방향일 때,  
    
          dp[i][j]를 두 정점에 대해 각각 0으로 초기화      
    (2-2) 간선이 일방향일 때,  
          
          dp[i][j]를 일방향인 곳에 0, 역방향인 곳에 1로 초기화  
    (3) 벨만-포드 알고리즘으로 모든 간선에 대한 최소거리 구함(역방향의 가중치를 1로 했기 때문에 dp[i][j]가 양방향으로 바꾸어햐 하는 값이 됨)      
    (4) 최소 개수 출력  
    (5) (4)를 k번 반복  

- ### 어려웠던 점  
  - 최소거리를 구하는 플로이드-와샬 알고리즘에서 양방향으로 바꾸어야 하는 길의 개수를 구하는 것으로 적용하는 것이 어려웠다.   

- ### 복잡도  
  - 시간 복잡도: O(N^3)  
    (2) O(M) + (3) O(N^3) + (5) O(K) = O(N^3)  
    
  
