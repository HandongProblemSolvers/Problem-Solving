// Lazy Propagation_스위치_1395

- 이해한 문제내용
	- 입력에 따라 A번부터 B번 사이의 스위치 상태를 반전시키거나 C번부터 D번 사이의 스위치 중 켜져 있는 상태의 스위치의 개수를 세는 프로그램으로 입력에서 켜진 스위치 개수에 대해 물을때 그에 따른 답을 한 줄에 하나씩 출력

- 접근방식
	- Lazy Propagation
	- 세그먼트 트리로 부분합을 저장해 놓는 방식이지만 update 할 때 어떻게 해 줄 것이다 라는 정보를 바로바로 갱신하는 것이아니라 그 정보를 해당 노드에 저장해 두었다가 후에 본 노드 혹은 그의 자식 노드를 방문할 때 lazy에 해당하는 값을 전파시키고 그 값은 중복 적용되는 것을 방지하기 위해 0으로 초기화 시킨다. => 시간을 절약
	
	- Analysis
1. propagation 함수 : lazy가 존재하는 노드(O가 1이 었을 경우에 true로 존재)를 방문할 경우 스위치는 모두 반대로 적용되므로 seg[node] = (e - s + 1) - seg[node] 라는 식을 통해 범위 내에서 원래값의 반대 경우를 구할 수 있다. 그리고 그 lazy 정보를 자식 노드에게도 전파하고 본인의 lazy 정보는 초기화, 즉, false 로 바꾼다. 
2. update 함수 : 제목 그대로 갱신하는 함수로 propagate 함수를 불러와서 lazy 정보를 지닌 노드를 지날 때마다 그 값을 적용시켜주고 부모의 값들도 갱신하여 seg[node] 값을 구한다
3. count 함수 (query라고 주로 되있던 함수) : 동일하게 propagate 함수를 불러주고 해당 범위 내에 있다면 바로 seg[node]를 return 하고 그렇지 않다면 범위에 해당하는 값을 찾아서 return 
- 값을 변화시켜 줄 때 XOR 활용

- 어려웠던 점
	- 개념 이해에도 시간이 걸렸으며 블로그에서 제시된 코드를 분석하는데도 오래걸렸다.  
	- 본 코드를 구현하면서 아직 세그먼트 트리 자체도 구현에 있어서는 많이 어색한거 같다고 느꼈다
	- l<=s && e<=r 이 범위에 대해서 계속 헷갈렸다
	- 이사한다고 시간을 많이 쏟지 못했습니다.. ㅠㅠ

- 직접 코드를 짜기보다는 각 함수들을 이해하고 분석하여서 코드는 제출하지 않았습니다..

- 시간복잡도 : O(MlogN)