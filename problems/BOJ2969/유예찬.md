### **내가 이해한 문제내용**
- 일단 출제를 잘못했다 죄송합니다 ㅠ_ㅠ. (DP를 넘 만만히 보았다...)
- 메뚜기처럼 (R,C)에서 뛰어다니는데 항상 꽃잎수가 더 많은 곳으로 뛰어야 한다.


### **접근 방식**
- 처음에는 단순한 DFS형태로 접근했다.
- O(N^3)은 시간초과이다 ^^
- 다음으로 생각한 형태는 row와 col의 정보를 재활용하는 방법을 모색했다. (이분탐색, segment Tree) 또한 그래프 형태도 생각해 보았지만 메모리 초과 떳다 ㅎㅎ...
- 이제 모르겠어서 하람이형이 준 영어 답안을 보고 감을 잡았다(나는 바보다)
- 신나는 DP다. 형태속에서 가지는 아름다움을 느꼈다.
- 라인 스왓핑도 섞이는데, 먼저 꽃잎들을 sort한 뒤에 작은 꽃잎 부터 DP에 접근한다.
- 작은 꽃잎 부터 접근하여 DP를 채우면, DP 값은 모두 현재 꽃보다 작은 꽃잎일 것이다.
- 위에서 같은 꽃잎수인 경우 DP에 바로 업데이트 되지 않도록 Queue에 저장한 뒤에 꽃잎수가 변할때에 업데이트 하게 하였다.
- 꽃잎을 업데이트 하는 경우 참고 가능한 DP 좌표는, `현재 좌표가 (R,C) 인 경우 (R-1, x), (R+1, x), (y, C-1), (y, C+1) [x,y]는 임의에 값` 좌표 값 중에 최대 값을 찾아야 한다.
- 여기서 처리해 주어야 하는 부분은 (R,C)에서 8방위에 위치한 좌표는 접근할 수 없음을 처리해야한다. (9개 좌표) = '(R-1, C), (R-1, C-1), (R-1, C+1), (R, C+1), (R, C-1), (R+1, C-1), (R+1, C), (R+1, C+1)'
- `각 행,열 에서 접근할 수 없는 값을 최대 3개이다.` 이를 이용하여 `각 행, 열에서 최대값 4개를 DP에 저장하면` 항상 행과 열에서 메뚜기의 뛰는 조건을 만족하는 최대값을 찾을 수 있다. (최대 값 4개가 모두 조건에 걸리는 경우는 없음.)
- 자 끝낫다. 여기서 꽃잎을 접근을 할때, 입력으로 주어지는 (R,C)가 시작으로 DP값이 1이 되어야 하고 이보다 큰 꽃잎부터 DP 업데이트를 시작하면 된다 ^^

### **어려웠던 점**
- 이렇게 풀어보긴 오랜만이다. 모두에게 조의를 표한다.
- 메뚜기 조건에서 최대값 4개를 선별하는 조건을 생각하는 부분이 하이라이트 인거 같다.

### **시간 복잡도**
  - `O(N^2)`