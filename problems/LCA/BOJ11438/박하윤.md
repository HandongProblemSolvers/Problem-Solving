// LCA_LCA2_11438

- 이해한 문제내용
	- 한 트리가 입력되고 두 노드의 쌍이 주어질 때 두 노드의 가장 가까운 공통 조상이 몇 번째인지 출력

- 접근방식
	- 함께 보내준 <https://m.blog.naver.com/kks227/220820773477> 링크를 보면서 공부
	- 노드의 높이(깊이)를 맞추어 준 이후 2^k 씩 올라가서 공통된 부모 노드를 찾아 준다 => 하나씩 하면 시간이 오래 걸리므로 각 노드마다 2^k번째 부모를 미리 저장	
		- parent[u][k+1] = parent[parent[u][k]][k]
		- 2차원 배열 : parent[u][k] => 정점 u의 2^k번째 부모
	- 트리의 깊이와 부모노드에 대한 정보는 DFS를 통해서 형성시켜준다.


- 어려웠던 점
	- 블로그를 보면서 이해하여 수월하였지만 처음 2차원 배열의 구조를 이해할 때 등 여러가지로 어려운 개념이 있었다.
	- 코드도 분석하여 이해했다고 생각했는데 혼자 구현하다가 다시 돌아가서 보다가를 반복하였다.. 그런데 컴파일 에러 ㅠㅠ => 내일 다시 확인

```
if(u != v){
      for(int i = max_k-1; i >= 0; i--){
        if(parent[u][i] != -1 && parent[u][i] != parent[v][i]){
          u = parent[u][i];
          v = parent[v][i];
        }
      }
      u = parent[u][0];
    }
```
- 위의 코드가 헷갈렸었다. 바틈업으로 같은 부모를 찾게 되는 코드인데 같은 부모를 찾으면 for문만 계속 돌아가고 u가 나오는데 같은 부모를 찾기까지 올라간 u가 u와 v의 lca 이다.. 라고 일단 이해함
	
- 시간복잡도 : O(MlogN)