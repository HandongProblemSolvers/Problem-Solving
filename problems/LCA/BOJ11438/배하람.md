- **내가 이해한 문제내용**
  - 트리가 주어지고 쿼리로 2개의 노드가 주어질 때 해당 노드들의 최소공통조상(LCA)을 찾아라.
- **접근 방식**
  - 라이님 블로그 보면서 공부하니 이해가 수월했다.
  - 구현과정
    - DFS를 이용해 `depth` 와 `parent[i][0]` 를 초기화한다.
    - `parent[i][j+1]=parent[parent[i][j]][j]` 임을 이용해 전체적인 `parent` 를 초기화한다. (이 때 `j` 를 반복할 때 위에 두는 것이 중요한데 이는 조상이 누군지 알아야 조상의 조상을 구할 수 있기 때문이다.)
  - 쿼리로 `u` 와 `v` 를 받는다고 했을 때 둘의 `depth` 가 같아야 하므로 비교해서 더 깊은 쪽을 `u` 가 갖도록 한다.
    - 이제 `depth` 를 맞춰주기 위해 `u` 의 `depth` 를 올리는데 이 때 binary lifting이란 것을 사용한다. 예를 들어, `depth` 의 차이가 11이라고 하면 이진수로 1011 인데 2로 나누어떨어지지 않을 때만 lifting을 하면 훨씬 빠르게 `depth` 를 맞출 수 있다.
    - 이제 `u` 와 `v` 가 같아야 하는데 같지 않을 경우에, 조상노드가 될 수 있는 최댓값부터 시작해서 조상이 같아질 때까지 계속하는데 이를 조상노드가 될 수 있는 최솟값까지 한다. 그 이유는 당연히 최소인 공통조상을 구하는 것이기 때문이다.
    - `u` 와 `v` 가 같다면 바로 출력하면 되지만 그게 아니라 위에서 걸렸다면 부모가 같은 것이기 때문에 한단계 올려야 한다.
- **어려웠던 점**
  - Binary lifting을 `u = parent[u][(int)log2(diff)]` 로 시도했었는데 이는 맞을 때도 있고 틀릴때도 있어서 라이님 방법대로 하는게 맞았다.
- **복잡도**
  - 쿼리가 M이니 O(MlgN) 이다.
