// union_방청소_9938

- 이해한 문제내용
	- 각 술병마다 넣을 수 있는 서랍이 두개씩 주어질 때 우선순위를 첫번째에 두고 채워져있으면 두번째 주어진 서랍에 넣는다. 만약 둘다 채워져 있을 경우 기존에 있던 술을 다른 서랍으로 옮기는 식으로 계속 이어나갈때 모든 술병을 서랍에 넣을 수 있는 경우와 아닌 경우를 출력

- 접근방식
	- 힌트를 통해 disjoint set인 유니온 파인드 알고리즘임을 알았다
	- 트리로 만들 서로소 집합의 원소가 술병인지 서랍인지 모르겠었다. 처음에는 술병이라고 생각했는데 술병은 항상 이동하는 원소들로 그 갯수를 제외하고 크게 상관없는 부분이니 서랍이 노드가 되고 그 간선은 차선책인 두번째로 주어진 서랍이 된다. => 루트노드는 빈서랍을 위한 용도
	- 단순하게 보면 서랍을 채울 수 있으면 채우고 채울 수 없다면 그 위 단계에 있는 서랍으로 이동하여 채워지는 형태이다. 또한, 한번 채워진 서랍은 다시 비워지지는 않는다. => 한 번 채워진 노드는 올라갈 수 없다.
	
--
- 주어진 룰 처럼 처음에는 a 그 다음에는 b가 채워져 있는지 확인하고 둘 다 채워져있는 경우에는 a의 루트노드 그 다음에는 b의 루트노드를 확인

- 어려웠던 점
	- 문제 자체를 이해할 때는 재밌었다.
	- 계속 거슬러 올라가서 채워져야 한다고 생각해서 재귀함수를 생각하였는데 1, 2번 경우가 안 되서 3,4번으로 넘어갈 경우 그냥 루트노드가 비어있는지만 확인하면 됬었다.
	- 트리의 연결이 헷갈렸다. 그림을 통해 이해하고자 했는데 트리의 연결이 헷갈려서 언제 유니온시키는지에 대한 규칙을 파악하는데 코드를 보고나서 이해됨 / 코드를 보았을 때 코드 자체는 간단해 보이는데 그 연결되는 개념을 이해하는데에도 시간이 오래걸렸다.
	- 초기화시킬때 인덱스 1부터 시작임을 고려하지 않아서 틀렸습니다 발생
	- find함수를 쓰지않고 바로 Parent 배열로 if문안에서 돌려서 틀렸습니다 발생
	
- 시간복잡도 : O(NlogN)


- 참고자료 : 
	- <https://mygumi.tistory.com/249>
	- <https://js1jj2sk3.tistory.com/19>