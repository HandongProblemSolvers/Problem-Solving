- **내가 이해한 문제내용**
  - 술병이 들어갈 수 있는 서랍 2개가 주어질 때 서랍들의 상태를 보고 술병을 넣을 수 있는지 판단.

- **접근 방식**
  - 처음에 해싱에서 open addressing과 구현방식이 비슷해서 이렇게 접근했으나 재귀함수의 스택 메모리 초과가 발생하였고 알고리즘 분류를 봤다.
  - 유니온 파인드라고 되어있었으나 어떻게 유니온파인드를 적용할 수 있을지 계속 고민해도 알 수 없었다. 그래서 [풀이](https://mygumi.tistory.com/249)를 보니 그래프 형식으로 사용하는 것이었다.
  - 가장 중요한 점은 **루트노드를 항상 빈 서랍으로 두고** 그에 맞게 유니온을 하는 것인데, 다음과 같다.
    - a를 채운다.
    - a에 이미 있으면 b를 채운다.
  - b에도 이미 있으면 a의 루트를 채운다.
    - b에도 이미 있고 a의 루트에도 있으면 b의 루트를 채운다.
    - 위 조건들 불만족시 SMECE
  - 한쪽을 채우면 채운쪽과 나머지를 유니온하는 방식, **나머지의 루트노드가 부모가 된다.** 이렇게 하면 find에서 path compression을 쓰기 때문에 빠르다.
  
- **어려웠던 점**
  - 유니온 파인드 문제중에 가장 어려웠음

- **시간복잡도**
  - O(Nalpha(N))
