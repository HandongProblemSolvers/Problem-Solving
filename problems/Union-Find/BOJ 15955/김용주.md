## BOJ15955 - 부스터

- 내가 이해한 문제내용
  - 체크포인트들의 좌표가 주어지고, 체크포인트 기준으로 움직일 수 있는 거리(HP)가 주어진다. 그리고 x축 또는 y축으로 원하는 만큼 이동할 수 있는 부스터가 있다. 이 때, 원하는 체크포인트 A에서 B까지 갈 수 있는지 없는지를 판단하는 문제다.
- 접근 방식
  - 처음에 접근한 것은 체크포인트에 hp와 boost로 나눠서 visit을 체크하면서 dfs로 경우의 수를 찾아보려 했으나 시간이 O`N^2`가 되어 포기.
  - 고민고민 하다가 답을 봤는데 답을 봐도 어려웠다. 비용이 hp보다 적은 간선만을 골라서 a,b까지 이동하는 방법을 찾는 형식인데 미리 간선들의 비용을 계산해놓고 hp보다 작은 비용을 가진 간선들의 정점들을 합쳐나가는 방식이다. 
    * 체크포인트에 도착했을 때 HP만 충전 or 부스터만 충전할 경우는 생각하지 않아도 되는 것이 어차피 처음 왔을 때 충전하고갔을때나, 나중에 충전했을 때나 똑같다.
    * 걷고 부스터쓰나 부스터쓰고 걸으나 그게 그거다. 그래서 부스터 먼저 써서 x축 or y축 방향으로 이동 한 다음 걸어갈 수 있는지(간선의 비용이 hp보다 작은지) 판단하면 된다.
    * A에서 B로 이동할 때 C를 거치면 A -> C -> B의 비용이 A -> B보다 작기 때문에 굳이 A -> B를 다시 확인할 필요가 없다.
    * 쿼리인 체크포인트 A, B, hp를 미리 다 받아놓고 비용이 hp보다 작은 간선만을 유니온파인드를 통해 정점들을 합쳐나간다. 우선순위 큐를 오름차순으로 정리해서 비용이 작은 간선부터 확인해 나간다. 그리고 비용이 hp보다 커지는 순간 힙을 빠져나와 A정점과 B정점이 연결되어 있는지를 확인해서 답을 저장해 놓은다. 이를 질문의 갯수만큼 반복하고 나중에 답을 출력한다.
- 어려웠던 점
  - 문제를 제대로 이해하지 못했다. 체크포인트에 갔을 때 피만 채우고 부스터 이미 충전이여서 나중에 다시와서 충전할수도 있다고 생각했지만 그것이 아니였다. 그냥 항상 부스터먼저 쓰고 보는것이 포인트였다.
  - `union find`를 항상 정해진 틀로만 사용하다 보니 조금 더 응용하는 곳에서 막혔다. 아직 제대로 이해하지 못했다... -> union을 할때 둘 다 루트거나, 둘의 부모가 같을 경우에는 둘 중 하나를 자식으로 설정한다. 연결이 되어 있을 경우 집합의 크기를 계속 root에다 추가시켜 준다.
  - sorting을 x좌표값과 y좌표값 2개로 나누고 이를 `우선순위 큐`에 넣었는데 x와 y좌표의 비용을 하나로 통일한다는 생각을 해보지를 않았다.
- 복잡도
  - 시간복잡도:  체크포인트의 수 N, 질의의 수 Q  
    * X좌표, Y좌표 순으로 정렬 NlogN, 쿼리도 정렬 QlogQ = `O(NlogN + QlogQ)`
