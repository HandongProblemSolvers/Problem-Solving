- **내가 이해한 문제내용**
  - 길이가 N인 4개의 배열이 주어진다. 이 4개의 배열의 요소를 1개씩 골라서 0으로 만들수 있는 경우의 수의 개수를 출력하라.

- **접근 방식**
  - 일단 저번에도 이런 형태를 풀었어서 배열 2개를 2개씩 합쳐서 N * N 크기에 배열에 각각 저장한뒤 sorting하고 Two-pointer를 적용했다.
  - 틀렸다... 계속 바꿔 봣는데 안된다. ㅠ_ㅠ
  - 그래서 그냥 이분탐색 형태로 바꿨는데 된다.
  - 일단 생각상으로는 Two-pointer(O(N^2))가 이분탐색(O(N^2log(N^2)))보다 속도가 빠를것이라 생각 되지만 모르겠다... 나중에 바꿔봐야겠다.

- **어려웠던 점**
  - 투포인터... 하하 구현을 잘못한것 같지는 않아서, 왜 투포인터가 안되는지 Greedy Algorithm이 아닌 Binary Search(sudo polynomial)형태만 되는 이유가 궁금하다. ㅠ_ㅠ 알려줘요...

- **시간 복잡도**
  - `O(N^2log(N^2))`