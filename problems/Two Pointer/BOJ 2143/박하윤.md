- 내가 이해한 문제 내용
	- 입력 : T (부분 합으로 나와야 하는 값), n => n개의 A배열, m => m개의 B배열
	- 출력 : A와 B 배열의 부분 합이 T가 되는 경우의 수를 구하는 것

- 접근방식
	- 보고 시작해 버렸는데 부분 배열의 합은 투 포인터의 활용이 많은 듯하다
	- RULE:
		- A와 B의 배열 둘 다 사용되어야 한다. 
	- 하 배열에서의 부분 합만 익혔기에 두 배열을 합쳐서 하나로 만들까도 생각해보고 포인터를 각 배열마다 두개씩해서 구간을 정해서 계속 두 배열에서의 합을 구하는 방식도 생각해봄
	- 시간 상.. 일단 풀이를 먼저 봤다

~~~
	A로 만들 수 있는 부배열의 합을 미리 다 구한다.
	B로 만들 수 있는 부배열의 합을 미리 다 구한다.
	B를 정렬 (바이너리 서치를 위함)
	A의 원소를 하나씩 탐색하며 T와의 차이 값이 B에 몇 개 존재하는 지를 찾는다.
~~~


- 어려웠던 점
	- 투 포인터의 개념부터 공부해서 1차원 배열에서 두 포인터(s,e)가 한칸씩 증가하는 방식임을 알았는데 바로 두개의 배열로 활용하여야 해서 어려웠다.
	- 풀이를 보고나니 너무 내 사고가 한정적이었다고 생각됬다. 
		- 두 배열의 합을 미리 구한다는 생각 + 두 배열의 가장 왼쪽을 s 가장 오른쪽을 e로 지정해도 됬는데 s,e를 같은 장소에서 시작하여 넓혀 가야만 한다고 생각했었음
	- cnt의 타입을 int로 하면 틀리고 long long 으로 하면 맞다.. => 그냥 돌렸을 때는 둘다 case problem 의 답을 출력하였는데 이유는 모르겠다..
	- 투 포인터 문제를 몇번 풀었었지만 이번에 제대로 개념을 숙지하였기에 기본문제도 풀지못하고 응용문제를 풀면 이해가 안 된 상태에서 넘어갈 듯 해서 기본 문제를 완전히 익히는걸 우선으로 하였다. (2003 문제)
	

``` c
#include <cstdio>

int main(){
  int N, M, A[10001];
  int s = 0, e = 0, cnt = 0, sum = 0;

  scanf("%d %d", &N, &M);
  for(int i = 0; i < N; i++)
    scanf("%d", A+i);

  while(1){
    if(sum >= M) sum -= A[s++];
    else if(e == N) break; // e가 완전 끝난 상태에서 s를 증가하더라도 sum보다 작은 수만 나올 것이다
    else sum += A[e++];
    if(sum == M) cnt++;
  }
  printf("%d\n", cnt);
  return 0;
}
```
// 이 문제는 진짜 개념만 적용하면 되는 문제였어서 쉬웠다. (처음에 풀었을 때는 while문 안에 다시 for문을 돌려 복잡해졌었지만 코드를 참고하여 보았을 때 훨씬 간단한 코드가 가능하단걸 알게됨)

- 시간복잡도: O(N^2)

- 참고자료 : <https://debuglog.tistory.com/155>


- 배운 점
	- 투 포인터
	- lower_bound, upper_bound
		- <http://www.cplusplus.com/reference/algorithm/upper_bound/>

```
##투 포인터
	 주어진 값들이 연속된 경우에만 활용 가능! (보통 배열 혹은 정렬된 데이타)
    연속성이 무조건적인 선행조건!!
	
#####Ex) 배열의 부분 합을 구할 때 (2003번 문제)
	모든 원소가 자연수일 경우에 적용
 
1. 시작과 끝 포인터 두개를 만든다. (s, e]
	- 이 때 끝 포인터의 경우 포함하지 않아야 한다 (in other words, 처음 시작할 때 (0,0] 으로 아무것도 포함하지 않는 상황으로 시작 
	- 조건 : 항상 s < e
	
2. (0,0]을 시작으로 두 포인터 사이의 부분 합을 구한다.
	* 부분 합이 원하는 값 이상일 경우: 시작 포인터를 오른쪽으로 한 칸 옮기기
	* 부분 합이 원하는 값 이하일 경우: 끝 포인터를 오른쪽으로 한 칸 옮기기
	* 부분 합이 원하는 값 일 경우: count++
	* e가 배열의 끝에 다다를 경우 s만 계속 증가시키다가 s 역시 끝에 도달하면 loop break

==> 투 포인터를 활용할 경우 각 포인터는 한 칸씩만 이동하니 놓치는 부분합은 존재하지 않게 된다. (모든 원소가 자연수 이기에 가능한 사실)

- 시간복잡도: O(N) => s < N 일 동안 반복되므로 
	- 만약 투 포인터가 아니라 배열 내에서 된다면 O(N^2) 이 되버린다,,

```



