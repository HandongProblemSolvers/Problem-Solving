- **내가 이해한 문제내용**
  - 배열 A와 B가 있을때 이 A의 부분합에 B의 부분합을 합쳤을 때에 값 T와 같은 경우의 수.

- **접근 방식**
  - 일단 문제를 보고 나서 처음에 부분합과 탐색을 위한 알고리즘 Segment Tree, Two-pointer, Binary Search 등을 생각한 뒤에 N에 적합한 알고리즘의 Upper Bound가 O(N*NlogN)임을 확인했다.
  - 이러한 부분 합들의 경우의 수는 최대 N(N+1)/2개가 있음을 확인했다.
  - 이러한 점에서 각각 모두 구한 뒤에 A와 B의 부분 합을 모두 구하고, 이를 A를 오름차순으로 접근하며, (T-부분합A)의 값이 부분합B에 몇개나 존재하는지 map를 이용하여 처음에 풀었다.
  - 이 뒤에 최적화를 위해서 부분 합 구하는 부분을 최적화 하고 map를 사용하지 않는 Two Pointer 형태로 문제를 변경시켰다.

- **어려웠던 점**
  - 처음에 N에 대해서만 생각했는데, 부분합의 형태로 배열을 생각하기까지 시간이 걸렸다.
  - Two pointer형태 최적화에서 A와 B의 접근 형태가 생각하기가 조금 어려웠다.

- **복잡도**
  $(var): N=M
  - 시간복잡도: `O(N^2)`
  - 공간복잡도: dp에 사용한 메모리 `O(N^2)`