## BOJ1781-컵라면

- 내가 이해한 문제내용
  - 문제를 풀면 컵라면을 주는데 각 문제에 데드라인이 있다. 컵라면을 최대한 많이 먹는 방법은?
- 접근 방식
  - 맨 처음에는 아주 간단하게 데드라인 기준으로 오름차순 정렬을 하고 데드라인이 같으면 컵라면이 많은 것부터 앞에서 부터 하나씩 하나씩 빼서 하면 된다고 생각했는데 틀렸다. 질문을 보니 (3,1) (3,1) (3,1) (4,10) (4,10) 일 경우 22가 아닌 13이 되어버리기 때문.
  - 그 다음은 다익스트라 알고리즘에서 pq에서 이미 뺀 값을 다시는 안들어가게 하는 방법으로 while(visit)을 썻던 것이 기억나서 이번에는 다른방법으로 접근했다.
    - 컵라면 기준으로 정렬한 다음 지금 풀 문제의 데드라인이 이미 visit되어 있는지 확인한다.
    - 만약 visit되어 있다면 데드라인을 한칸 내려서 확인하고 0이 되면 이 문제는 풀 필요가 없는 것이 되므로 skip하는 형식으로 했다.
    - 근데 그렇게 하면 데드라인이 모두 20만이고 총 20만개를 할 때 거의 n^3의 연산을 하게 된다. 그래서 시간초과
    - 이 문제를 해결하기 위해 문제의 데드라인이 0에 도착한 적이 있으면 더이상 이와 같은 문제들은 풀 필요가 없으니 모두 스킵하게 했다.
- 어려웠던 점
  - 풀고 보니 시간이 532ms가 나왔는데 만약 test case가 더 어렵게 짜여졌다면 이 알고리즘 역시 시간초과가 나왔을 것이다. 만약 이 방법으로 하려면 유니온파인드 형식으로 해서 visit의 앞뒤를 확인해서 둘다 값이 true면 연결하는 형식으로 해서 한번에 많은 칸을 뛰어넘는 방식으로 구현해야 할 것이다.
  - 여행하면서 예찬이가 힌트를 heap라고 줬는데 모르겠어서 이렇게 풀었다. 근데 heap쓰면 nlogn이니까 시간이 100ms 이하로 되는 것 같다. 이 방법도 공부해 보기로(여행끝나고...ㅎ 근데 할지는 모르겟읍니당)
- 복잡도
  - 시간복잡도:  `O(n^2)` 지만 test case 덕분에 어찌저찌 넘어갔다...ㅎ
