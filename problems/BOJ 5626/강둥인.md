#내가 이해한 문제내용

우선 제단의 각 높이는 모두 정수이고 가장 처음에 모든 열의 높이는 0인 N열짜리 제단을 만든다.
제단을 만드는 과정
1. 같은 높이를 가지는 연속하는 열을 선택한다.
2. 그 다음 선택한 첫 열과 마지막 열을 제외한 모든 열의 높이를 1만큼 올린다.

이렇게 만든 제단의 일부 열을 도둑 맞아 일부 열의 높이 정보만 남아있을 때, 남아 있는 열들의 정보를 가지고 가능한 원래 제단의 경우의 수를 구하는 문제


#접근방법
 - 생각의 흐름
  1. 높이가 1이 높아지거나,낮아지거나,그대로이거나 3가지 경우가 있다.
    => dp[i][k]=dp[i-1][k-1]+dp[i-1][k]+dp[i-1][k+1]

  2. 첫 열과 마지막 열의 높이는 0이다.
  3. 인접한 열의 차이는 최대 1

 - 알고리즘: DP

# 어려웠던 점 및 새로운 알고리즘
배열로 모든 높이에 대해서 만들어 주게된다면 메모리 초과가 된다.
오랜만에 보는 모듈러 연산..

Sliding Window Algorithm (선택)
저번에 학습했던 투 포인터 알고리즘과 비슷하나 윈도우의 크기가 고정이라는 점만 다르다.
투 포인터에 대한 설명은 저번에 썻으니 생략..
+---------------------------------+---------+
|      Windows Position           |   Max   |
+------------+----+---+---+---+---+---------+
|[1   3   -1]| -3 | 5 | 3 | 6 | 7 |    3    |
+------------+----+---+---+---+---+---------+
| 1 |[3   -1   -3]| 5 | 3 | 6 | 7 |    3    |
+---+-------------+---+---+---+---+---------+
| 1 | 3 |[-1   -3   5]| 3 | 6 | 7 |    5    |
+---+---+-------------+---+---+---+---------+
| 1 | 3 | -1 |[-3   5   3]| 6 | 7 |    5    |
+---+---+----+------------+---+---+---------+
| 1 | 3 | -1 | -3 |[5   3   6]| 7 |    6    |
+---+---+----+----+-----------+---+---------+
| 1 | 3 | -1 | -3 | 5 |[3   6   7]|    7    |
+---+---+----+----+---+-----------+---------+


#복잡도
 - 시간복잡도: O(N^2)
 - 공간복잡도: O(N^2)
