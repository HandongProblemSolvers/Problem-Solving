//1150 백업

- 내가 이해한 문제 내용
	- 입력 : 회사의 수 n, 네크워크 테이블 수 k, 출발점에서 각 회사까지의 거리 s (순서대로 주어짐)
	- 출력 : 2k의 서로 다른 회사를 k쌍으로 묶었을 때 필요한 가장 짧은 전체 네크워크 케이블의 길이
	- 회사 두개를 서로 연결하는 네크워크 케이블의 길이가 최소가 되게 하는 경우
	
- 조건 
	1. 어떤 회사도 2개 이상의 쌍에 속할 수 없다 (2k개의 회사가 모두 다른 회사)
	2. 짝 지어진 두 회사간의 거리들의 전체 합을 최소화 하도록 짝짓기 
		* 순서대로 거리가 주어졌으므로 최선의 짝 짓기는 인접한 회사들! 	

- 접근방식
	- 먼가 DP 문제같은 느낌이었지만 시간복잡도 때문에 그리디라고 한다 => 둘은 서로 같이 쓰인다고 함 (DP와 그리디)
	- 조건을 살펴보면 인접한 회사들끼리의 사이 거리를 구하고 그들 중 min을 k번 찾아서 각 min의 합을 출력하는 형태로 이해했었지만.. => *그리디 알고리즘의 정의와 비슷한 방법으로 접근하고자 했었다.(현재 상황만 보고 처리하기)*
		- 예외: 가장 min을 값으로 가지게 되면서 그 회사와 가까이 연결되어 있었던 또 다른 회사와 그 옆 다른 회사와의 거리가 상당히 멀 경우 결국 결과값은 min이 아니게 되는 현상이 발생할 수 도 있다.. => 이 부분에 관해서 더 이상 생각의 진전이 없었다..
	- 반복문을 통해서 i번째와 i+1 번째 회사의 사이값이 제일 작은 값을 ans에 넣어주고 그 회사 두개를 제외하고 나머지에서 똑같이 진행 k번 동안


- 어려웠던 점
	- 처음에 단순하게 생각했는데 예외 부분을 처리할려면 어떻게 해야 할지 최선의 대책이 생각이 나지 않아서 생각하다 시간을 보냄 => 알아보니 그리디 알고리즘이 원래 각 단계에서의 최적인 방안을 고려.. 
	- 구현을 막상 시작하니 꼬여서 잘 생각나지 않았다
	- 알고리즘관련해서는 DP와 그리디가 아직 구분이 잘 안간다. 접근하는 시각의 차이인거 같은데 구현에서는 정확히 뭐가 다르다고 설명 할 수가 없다.
	- 시간 부족도 포함.. 나중에 코드 분석하면서 공부해야겠다..


- 시간복잡도: O(N) ..?


- 코드 참고
	- <https://zychspace.com/blog/5b44b3a7f302ac78463a50e9>
	- => 코드를 보고도 이해가 잘 안되서 일단 제출하고 맞은 분들의 풀이를 또 보았지만.. 여전히 어렵고 완벽히 이해가 가지는 않는다.. 일단 참고한 코드 복사해서 코드에 올려놓음



#### 그리디 알고리즘
	각 단계에서 최선의 선택을 하는 기법
	현 시점의 정보를 바탕으로 가장 이익이 되는 원소들을 선택하는 방법
	최적화 문제(optimization problem)'를 해결하기 위한 방법

- 각 단계에서 최선의 선택을 하는 알고리즘으로 DP때 많은 일을 한다는 생각에서 일을 줄이기 위해 나온 알고리즘
- 전체의 최선이 아닐 경우도 발생함
- 3가지 단계를 거쳐 최적해를 구함
	1. 선택작업 : 현 상테에서 최적해에 포함시킬 대안을 선택
	2. 타당성 조사 : 선택된 해가 주어진 문제의 조건을 만족하는지 검사
	3. 해답 조사 : 원래의 문제가 해결되었는지를 조사


- 이를 활용하는 다른 알고리즘 : 
	- 프림 알고리즘, 다익스트라 알고리즘, 최소 신장 트리

- 출처 :

	- <https://www.zerocho.com/category/Algorithm/post/584ba5c9580277001862f188>
	- <https://eehoeskrap.tistory.com/38 [Enough is not enough]>





