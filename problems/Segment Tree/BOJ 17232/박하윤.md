// 생명게임_17232

- 이해한 문제내용
	- 바둑판의 칸을 (i,j)로 하였을 때 (i-K), (i+K), (j-K), (j+K) 을 꼭짓점으로 두는 정사각형에서 (i,j)를 제외하고 해당 칸에 생명이 있고 범위내에 a 이상 b 이하의 생명이 존재하면 그대로 유지되고 나머지의 경우도 죽음 / 해당 칸에 생명이 없고 a 초과 b 이하라면 다음 단계에서 생명 탄생

- 입력 : 바둑판의 갯수(N*M), 시간(T), 주위의 기준 (K), a와 b, N개의 줄에 생명이 있는 칸은 별 빈칸은 점
- 출력 : 바둑판의 상태 -> N개의 줄에 별과 점


- 접근방식
	- 처음엔 그냥 하나씩 확인해주는 완전탐색을 생각 => 시간초과..될꺼 같았다
	- 구간합을 구하기 => 세그먼트 트리..? 2차원 세그먼트 트리.. 
	- 예찬오빠 md & 코드 봄 -> 2중 for문으로 dp에 누적으로 생명의 갯수 합을 저장
	- dp 식 : dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1] + (board[i][j] == '*')
		- 그림그리면서 이해 => 보드에서 구간합처럼 dp를 통해 오른쪽 아래로 갈수록 포함하는 범위를 넓히기 / 여기서 dp[i-1][j-1]는 중복되는 구간을 없애기 위해 필요 
		- 젤 왼쪽 행은 본인과 위에 있는 칸들을 포함하는 직사각형! 

- 궁금한점
	- if(map[i][j] == "*") 이런식으로 비교하여 dp에 +1 해 주었는데(답은 제대로 안나왔지만..) (board[i][j] == '\*') 이렇게 괄호내에 if의 조건이 들어간다면 무슨 작용..? 코드를 볼 때는 같으면 +1 시키는데 처음보는 거 같다.
	
	- int life = dp[down][right] - dp[down][left] - dp[up][right] + dp[up][left] - (board[i][j] == '*');
	- 여기서 나머지는 이해가 되지만 dp[up][left] 는 왜 더해주는 걸까..? 전체(정사각형의 아래쪽 꼭짓점)에서 왼쪽아래부분과 오른쪽위를 잘라낸다고 보면 딱 원하는 정사각형의 범위가 나오지 않나..?  => 부분합 정리된 부분을 보고 이해됬다!
	
- 어려웠던 점
	- 혼자 고민 제일 많이 한건..dp에 어떤식으로 저장할지.. 결국 봤지만 ㅠㅠ
	- 한번 다시 정리하면서 풀어봐야겠다.
