# 내가 이해한 문제내용
한 수열에 대해서, 구간을 잡고 그 구간의 모든 원소의 곱을 출력하는 프로그램
수열의 각각의 원소는 command로 인해 값이 바뀔 수 있다.

# 접근방법
- 생각의 흐름
그냥 날코딩 하면 될 것 같았다.
어레이에 수열을 저장하고 change 명령을 받을 때마다 어레이값을 바꿔준 뒤
P가 나오면 모든 배열값을 곱하는 것으로 접근했다.

- 사용한 알고리즘 혹은 접근법
결과는 역시 실패,, 검색을 해보니 구간합, 구간계산을 할 때는 segment tree를 사용하는 것이 효율적이라고 한다.



# 어려웠던 점 및 알게된 새로운 알고리즘
 - Segment Tree
 배열의 부분 합을 구할 때, 배열값이 바뀌는 경우 부분 합을 트리구조에 저장함으로 O(logN)의 속도로 배열의 부분 합을 구할 수 있게한다.

  * 구조(배열의 크기 N = 10)
                 0~9
              /       \
            0~4          5~9
          /    \       /    \
        0~2   3~4    5~7     8~9
      /   \   /  \  /   \   /   \
    0~1   2  3   4 5~6  7  8     9
  /    \          /   \
 0      1        5     6

 1. leaf node의 갯수: N
 2. 트리의 높이(H): logN
 3. 배열의 크기: 2^(H+1)

  * 코드
long long segment(int index, int start, int end) {    
    if(start == end)
        tree[index] = A[start];
    else
        tree[index] = init(index * 2 + 1, start, (start+end)/2) + init(index * 2 + 2, (start+end)/2 + 1, end);

    return tree[index];
}

 * 구간 합 구하기
 탐색 범위인 [start, end]에서 구하려는 합의 범위인[left, right] 구간의 관계는 다음과 같은 4가지 경우가 있습니다.

  1. [left, right] 범위가 [start, end]와 전혀 겹치지 않는 경우
    -> 찾으려는 범위가 전혀 겹치지 않으므로, 더 이상 자식 노드로 탐색할 필요없으므로 그냥 0을 반환하면 됩니다.
  2. [start, end] 범위가 [left, right]에 완전히 속해 있는 경우
    -> 탐색 범위가 구하려는 전체 범위에 포함되므로, 하위 노드를 탐색할 필요 없이 start에서 end까지의 합인 tree[index]를 반환

  3. [left, right] 범위가 [start, end]에 완전히 속해 있는 경우
  4. 그 외의 경우 (범위가 일부분 겹치는 경우)
    -> 하위 범위를 탐색하며 그 범위가 1, 2번의 경우에 해당되는지 아니면 더 하위범위를 탐색할건지 판단해야 하므로, 재귀 호출을 실행.

  * 값 업데이트
  0 (value - A[changed_index])를 diff에 넣습니다.
  0 A[changed_index]에 value 값을 넣습니다.
  0 탐색 범위를 나눠가며 노드가 리프 노드가 될때까지 (start == end) 다음과 같은 일을 수행합니다
    - 변경하려는 changed_index가 탐색 범위[start, end]를 벗어났을 경우에, 더 이상 하위 노드를 탐색할 필요가 없으므로, 함수를 종료합니다.
    - 위의 경우가 아닐 땐 해당되는 노드에 diff 값을 더해줍니다.

# 복잡도
- 시간 복잡도: O(logN)
- 공간 복잡도: O(N)
