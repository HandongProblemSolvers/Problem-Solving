## BOJ7578 - 공장

- 내가 이해한 문제내용
  - A열과 B열에 있는 기계들은 서로 짝을 가져 연결되어 있는데 그 짝을 서로 선분으로 잇고 이 선분들이 얼마나 교차되어 있는지의 수를 세는 문제.
- 접근 방식
  - 처음에는 또 교차점 찾는 문제라 A열을 기준으로 B열을 비교하려고 했다. 근데 조건이 너무 많았다. 교차점이 있으려면 (A보다 오른쪽, B보다 왼쪽) 또는 (A보다 왼쪽, B보다 오른쪽)의 경우를 서로 만족해야 하는데 이를 일일이 확인하기에는 N의 수가 너무 컸다.(50만)
  - 그래서 뇌정지와서 알고리즘 분류를 봤는데 세그먼트 트리인걸 보고 2차 뇌정지가 왔다. 사실 세그먼트트리 이름만 봐도 문제 풀기가 싫다.
  - 근데 이걸 어떻게 구간을 나눠서 하는지 몰라서 결국 풀이를 봤다.
    - 구간합을 이용하는 문제인데, 세그먼트트리는 일종의 visit 역할을 한다.
    - 맨처음 왼쪽에서 시작할때는 당연히 하나도 겹치는게 없고 tree에 A열에 있는 기계의 위치에 해당하는 부분을 1로 만든다.
    - 그 다음부터는 구간합을 하는데 그 구간은 A열과 짝인 B 기계의 index ~ 마지막이 된다. 구간합을 다 더해서 출력하면 교차점의 수가 된다.
    - 여기에 나온 예시를 보자면 A의 1번은 B의 3번과, A의 2번은 B의 1번과 연결이 되어있다. 그러면 처음 실행할 때 B의 3, 4, 5번의 구간합을 더하는데 처음이니 당연히 tree는 모두 0이다. 다 돌고나서 3번에 1을 채워 놓는다.
    - 그 다음은 A의 2번차례다. B의 1번과 연결되어 있으니 구간합은 1~5까지가 된다. 이 때 3에만 1이 있으니 교차하는 선분은 1개가 된다. 이를 모든 A에 반복해준다.
- 어려웠던 점
  - 세그먼트트리의 구조를 매번 갖다쓴다... 직접 구현해야 하는데 update는 어느정도 기억나지만 구간에서 활동하는 것을 정하는 부분은 변수가 5개나 있어 헷갈린다
  - 근데 애초에 이 문제를 세그먼트 트리라고 생각하지도 못했다...
  - 게다가 계속 틀렸길래 왤까하고 확인했더니 그냥 A열과 B열의 mem size를 늘렸더니 해결되 버렸다. 며용
- 복잡도
  - 시간복잡도: 세그먼트트리를 N번 업데이트 `O(nlogn)`
