* **내가 이해한 문제 내용**
  * A열을 순회하면섯 각 원소가 B열의 어떤 위치에 있는지 확인하고, 해당 위치의 앞쪽에 있는 원소들 중에 자신의 A열 위치보다 앞에 있는 것들의 개수 총합을 구하시오.
* **접근 방식**
  * 먼저 나이브하게 접근했을 때는 O(N^2)였기 때문에 당연히 안 풀렸고 고민하다가 이분탐색 쓰면 될 것 같아서, 이분탐색을 활용하였다.
  * 정렬을 해야 이분탐색을 쓸 수 있기 때문에 정렬을 어떻게 하면 순회할 때마다 적용시킬 수 있을까 생각함
  * set을 쓰면 된다는 것을 파악하고 사용하였지만 시간초과… 원인은 set이 아니라 distance 함수, 즉 iterator를 이용하여 길이를 구하는데 선형시간인 O(N)이 걸린다는 문제였다.
  * 이때서야 알고리즘 분류를 보니 세그먼트 트리, 생각하긴 했었지만 딱히 활용방안이 떠오르지 않아 넘겼는데...
  * 어쨌든 세그먼트 트리를 활용하는 걸 생각해 보았다.
    * 예제의 경우 A열을 기준으로 B열의 인덱스를 나열하면 3, 1, 4, 2, 5가 된다.
    * 여기서 각 원소를 순회하면서 앞쪽에 자신보다 큰 숫자가 몇 개 나오는지 판단하는 쿼리를 O(lgN)안에 날릴 수 있는 세그트리를 구축하면 된다.
    * 하지만 어떻게 구축해야 될지를 모르겠다….
  * [풀이](https://www.crocus.co.kr/782)를 보고 이해한 뒤 구현하였다.
    * 세그트리를 부분합으로 활용하는 방식이다.
    * 내가 생각한 기존 방식과 동일하지만 B에 해당하는 각 인덱스를 볼 때 그 인덱스 이후의 부분합을 보는 형태인데, 바로 현재 인덱스 이후에 이미 연결한 지점이 있는지 보는 방식이다.
    * 주어진 예시에선, 132가 A의 인덱스는 1, B의 인덱스는 3이므로 4~5의 부분합 쿼리를 날려 이미 연결된 지점이 있는지 보는데 없기 때문에 B의 인덱스 3을 1로 업데이트 해준다.
    * 이후 392의 경우 B의 인덱스가 1이므로 2~5의 부분합 쿼리를 날린다. 위에서 인덱스 3을 1로 업데이트 해주었기 때문에 1이 돌아오고 이미 연결된 개수는 1이라는 것을 알 수 있기 때문에 겹치는 한쌍을 발견할 수 있다.
    * 이런 식으로 N번 순회하면 겹치는 모든 쌍을 확인할 수 있다.
* **어려웠던 점 & 배운 점**
  * 세그트리의 기본인 구간합, 구간곱, 최댓값, 최솟값을 구현할 수는 있었지만 활용하진 못했기 때문에 이런 문제에서 어려움을 겪었다. 하지만 좋은 문제였고 구간합을 이용하는 방법을 배울 수 있었다.
  * 세그트리의 많은 실수인 데이터 크기 문제, 처음 32비트 정수형으로 했지만 틀리길래 뭐가 문제일까 보니, 세그트리의 쿼리 자체가 범위를 넘진 않지만 답이 구간합을 계속 더하는 방식이기 때문에 64비트 정수형으로 해줘야 함을 배웠다.
* **시간복잡도**
  * N번 순회하면서 쿼리/업데이트를 하는데 O(lgN)이므로 O(NlgN)