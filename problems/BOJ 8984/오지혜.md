* 내가 이해한 문제내용

  - 특정 좌표에서 시작하는 막대기가 지그재그로 최대한 길게 이어붙이게 되려면, 각 좌표에서 가능한 막대기 중 
  
  - 가장 긴 것들을 이어가야 하므로 DP를 사용하여 업데이트 하면서 답을 찾고자 했다.  
  
  
* 접근 방식

  - DP 배열에 각 출발점 기준 제일 길게 막대기를 이어붙였을 때의 길이를 담고자 했다. 그리고 끝까지 가면 제일 큰 값을 출력하고.
  
  - 그런데 나는 좌표 t와 d를 묶어서 생각하고, 각각 분리하여 그때의 최적 값을 도출해 낼 수 있다는 점을 유도해내지 못했다. 
  
  - 즉, t와 d의 조합이 (4,5)일 경우, t에서 만나는 점들 중 가장 긴 막대기들을 선택하는 것과 반대편 d를 통해 이어붙일 수 있는 긴 막대기들을 고려하지 못한 것이다.
  
  - 그래서 처음 접근한 방식대로 바로 구현하는 것이 잘 안되었고, 이후 코드를 참고하여 나의 코드로 바꾸었지만 코드 에러 처리하기까지 개인적 시간이 현재 부족하다.
  
  - 따라서 내가 구현하고자 한 전체 프로세스를 적고자 한다.  
  
    1. 이차원 배열 stick에 좌표들을 담고, 배열 t와 d에 stick의 1열과 2열의 값을 각각 담는다. 이후 오름차순으로 정렬 후 중복 값은 제거한다. stick 또한 정렬.
    2. stick을 순차적으로 탐색하여 해당 값이 t와 d 배열 중 몇 번째인지 체크하여 해당 인덱스 값 x, y를 도출한다.
    3. DP_t, DP_d를 이용하여 x, y 인덱스에 길이를 저장하는데, DP_t로 설명하면, 이전까지 t값으로 저장해온 길이가 긴지, 다른편의 d를 통한 막대기 길이를 잇는 것이 긴지 비교하여 저장한다. 
       -> Max(t, d+length)
    4. DP의 값을 통해 가장 긴 막대기의 길이를 계산한다. 
    5. 전체 크기만큼 반복하여 최대 길이를 업데이트 해준다.
   
   
* 어려웠던 점

  - 앞으로 착실하게 알고리즘 공부 및 문제를 푸는 것이 현재 나에게 가장 중요한 일이라고 생각된다. 파이팅 
 
