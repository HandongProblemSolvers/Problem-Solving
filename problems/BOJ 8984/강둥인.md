#내가 이해한 문제내용
한 점에서 출발해서 지그재글 교차하지 않고 이어진 가장 긴 경로를 찾는 것

#접근방법
 - 생각의 흐름
하나씩 이어진 선을 모두 구한 다음 길이를 재고 비교해서 MAX값을 찾는다.
예제에서는 a-b-e와 c-d-f-g, c-e, d-e 4개가 있고 가장 긴 경로는 c-d-f-g이다.

첫번째 생각
연결 되어 있는 막대기는 pair 구조를 사용했을 때,
p[i].first를 i번째 윗쪽 좌표로, p[i].second를 i번째 아래 쪽 좌표로 생각했을 때,
if (p[i].second == p[i+k].second && p[i].first < p[i+k].first) 일 때 길이를 더해 나간다.
시간초과 ㅅ,,

두번째 생각
일단 중복점을 제거하며 윗줄 아랫줄 sorting을 해보자
  윗줄: {1, 2, 4, 6, 8}
  아랫줄: {0, 5, 8}
  =>  연결 정보를 어떻게 확인할 것인가?
  가령, 윗 1번과 아랫 0번은 연결되어 있지만, 윗 1번과 아랫 5번은 연결되어 있지 않다.
  한참을 생각하다 답지를 봤다.

  이해를 못하고 코드를 배끼는 건 의미가 없기 때문에 코드는 생략


 - 알고리즘: DP

# 어려웠던 점 및 새로운 알고리즘
위에서 언급했다시피 연결정보를 구현하는 부분에서 애를 먹었고, 사실 아직도 풀이를 봐도 이해를 못하겠다.. 내수준의 문제가 아닌가보다
또한 DP는 풀면 풀 수록 모르겠다. 열심히 하자

#복잡도
 - 시간 복잡도: O(NlogN)
 - 공간 복잡도: O(N)
