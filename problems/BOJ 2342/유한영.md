**내가 이해한 문제내용**

누구보다 적게 움직여서 ddr을 하자!

 <hr/>
 
**접근 방식**

1. 전 발판에서 다음 발판으로 넘어갈 때 무조건 전 발판에 발 하나는 있음
2. 예를 들자면 발판이 2 3 일때
   (0,2) (1,2) (2,2) (3,2) (4,2) 에서 다음 발판으로 가는 경우를 계산할 수 있다.
   (0,3) (1,3) (2,3) (3,3) (4,3) 
   
  - (0,2) -> (0,3) 1가지 경우
  - (1,2) (3,2) -> (1,3) 2가지 경우 
  - (0,2) (1,2) (3,2) (4,2) -> (2,3) 4가지 경우 
  - (4,2) (3,2) -> (4,3) 2가지 경우 
  첫번째 경우를 제외하고는 모두 가장 작은 값을 찾아서 배열에 저장하면 된다.
  
  각 경우를 비교할 때는 dp의 값은 같지만 발은 움직일 때 드는 힘이 다를 수 있으므로 dp의 값 + 드는 힘으로 비교 한다.
  
  세번째 경우에서는 (3,2) -> (2,3) 의 경우는 발의 위치가 같은 경우이므로 1만 더해준다.

 <hr/>
 
**어려웠던 점**

조건을 잘 정리했다고 생각했는데, 문제를 풀다보니 내가 놓친 부분이 계속 생긴다

<hr/>

**개념 정리**

Dynamic Programming

<hr/>

**복잡도**

O(N)

<hr/>

**피드백**

왜 기본 10번은 틀려야만 문제를 푸는 걸까요..
