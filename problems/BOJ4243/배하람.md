- **내가 이해한 문제 내용**
  
  - 각 상점간의 거리가 주어질 때 대기시간의 합의 최솟값을 구하시오.
  
- **접근방법**

  - 그리디로 접근했으나 1번째 예제만 통과.

  - 이후 dp로 점화식을 생각해봤으나 해결하지 못하고 [풀이](https://justicehui.github.io/icpc/2019/07/11/BOJ4243/) 를 봄. 이해하기 상당히 까다로웠음

  - ```
    dp[i][j][0] = pi~pj를 방문한 상태에서 pi에 있을 때 나머지를 방문해서 걸리게 되는 대기시간 합의 최솟값
    dp[i][j][1] = pi~pj를 방문한 상태에서 pj에 있을 때 나머지를 방문해서 걸리게 되는 대기시간 합의 최솟값
    ```

  - 결국 왼쪽 아니면 오른쪽으로 이동하기 때문에 왼쪽/오른쪽으로 보낼 때의 **가중치에 남아있는 상점 개수를 곱해서** 더해주는 방식을 사용하면 된다.

  - ```
    dp[i][j][0] = min(dp[i][j][0], dp[i-1][j][0] + dist(now, i-1) * 나머지)
    dp[i][j][1] = min(dp[i][j][1], dp[i][j+1][1] + dist(now, j+1) * 나머지)
    ```

  - 주목할 점은 문제의 특성상 이동했을 때 **반드시 왼쪽 끝, 아니면 오른쪽 끝에 위치하게 된다** 는 점이다.

  - 남아있는 상점 개수와 가중치를 곱하는 부분이 이해가 안됬었는데, 문제에서 요구하는 것이 대기시간으로 정의된 합이기 때문에 대기시간이 누적합인 것을 보면 이해할 수 있다.

- **배운 점**

  - 재귀 말고 [반복문으로 짠 코드](https://blog.myungwoo.kr/37?category=526554)를 보면서 생각하는 방법을 배울 수 있었다.

- **시간복잡도**

  - O(N^2)
