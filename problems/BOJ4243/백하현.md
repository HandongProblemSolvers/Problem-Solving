- ### 내가 이해한 문제내용  
  - 테스트 케이스의 수 T, 상점의 수 N(1<=N<=100), 시작점의 위치 a(1<=a<=N), N-1개의 줄에 pi와 pi+1을 오가는 데 걸리는 시간 t[pi,pi+1](1<=t[pi,pi+1]<=15000000)이 주어졌을 때,  
    
    (1) 대기시간 li는 a를 출발해 pi에 처음 도착하기까지 걸린 시간이다.  
    (2) 가게는 수직선 상에 놓여있다.  
    
    위의 조건을 만족할 때, 모든 가게를 방문하는 방법 중 대기시간의 합의 최소값 구하기  

- ### 접근방식  
  - dp[i][j][k] : (j ~ k번째 상점을 방문하였을 때 가장 마지막으로 방문한 상점의 방향이 i(0일 때 왼쪽, 1일 때 오른쪽)인 대기시간의 합)  
    w[i][j][k] : (j ~ k번째 상점을 방문하였을 때 dp[i][j][k]를 만드는 마지막으로 방문한 상점의 대기시간)  
    
 - 문제     
    (1) t[pi,pi+1]을 일차원 배열에 저장  
    (2) dp[i][j][k] 업데이트  
          
        dp[i][j][k]의 값이 존재할 때,  
          
        가장 마지막으로 방문한 상점의 방향이 왼쪽일 때,  
          
        dp[0][j-1][k] = min(dp[i][j][k] + w[i][j][k] + t[pj-1,pj], dp[0][j-1][k])
        dp[1][j][k+1] = min(dp[i][j][k] + w[i][j][k] + t[pj,pj+1]+t[pj+1,pj+2]+...+t[pk,pk+1], dp[1][j][k+1])  
        
        가장 마지막으로 방문한 상점의 방향이 오른쪽일 때.  
          
        dp[0][j-1][k] = min(dp[i][j][k] + w[i][j][k] + t[pj-1,pj]+t[pj,pj+1]+...+t[pk-1,pk], dp[0][j-1][k])
        dp[1][j][k+1] = min(dp[i][j][k] + w[i][j][k] + t[pk,pk+1], dp[1][j][k+1])  
    (3) (2)를 (N+1) * (N+1) * 2번 반복  
    (4) min(dp[0][1][N], dp[1][1][N])출력  
    (5) (1)~(4)를 T번 반복  
    
- ### 어려웠던 점  
  - 반례를 찾지 못하였다.  

- ### 복잡도  
  - 시간복잡도 : O(N^2T)  
    (3) O(2N^2) * (5) O(T) = O(N^2T)  
    
        
  
      
