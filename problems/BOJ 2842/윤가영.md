* 내가 이해한 문제 내용
  * P에서부터 모든 K를 돌고 P로 다시 돌아와야 함.
  * 이때, 피로도(최대높이-최소높이)를 최소로 하는 루트를 찾아야 함.

* 접근 방식
  * 처음에 TSP문제랑 비슷하다고 느꼈는데 여기서는 map에 그 node간의 이동거리를 담는게 의미가 별로 없는 것 같아서 다르게 접근해야 한다고 생각함.
  * 어쨌든 피로도를 최소로 하는 경로를 찾아야 하는데 감이 안왔다. 예제 코드를 봤을 때는 (0,0)을 1번 노드, (2,0)을 2번 노드, (2,2)번째 노드를 3번 노드라고 했을 때,
    p->1->2->3 ->p로 도는 거랑 그 거꾸로 도는거랑 피로도가 같다고 생각해서 모든 경로를 다 구해서 그때마다 피로도를 계산해야되나 생각했음.
  * 근데 모든 경로를 비교하는건 50!이라는 말도안되는 시간이 걸리기 떄문에 패스..
  * 어떻게 하는지 모르겠다.
  
* 어려웠던 점
  * 인터넷에 나와있는 코드를 봤는데 설명이 불친절해서 사실 잘 이해를 못했다.
  * 당연히 집 노드를 기준으로 근접노드를 살펴보면서 값을 찾아간다고 생각했는데 왜 최솟값을 기준으로 search를 해나가는지 잘 모르겠다..
  
* 복잡도
  * 

