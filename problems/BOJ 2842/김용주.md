## BOJ2842 - 집배원 한상덕

- 내가 이해한 문제내용

  - 우체국에서 모든 집에 다 배달하고 다시 우체국으로 오는 것이 목표인데 각 지형에는 고도가 있다. 이 고도의 차이가 가장 큰 것을 피로도라고 하는데 피로도의 최솟값을 구하는 문제.
- 접근 방식

  - 보자마자 BFS와 DFS를 떠올렸고 그냥 돌리면 시간초과가 날 것 같아서 DP랑 섞어서 하는 방법을 생각했다.

  - 문제는 DP랑 섞을 때 subproblem으로 적절한 것을 찾지 못했다.

  - 근데 DP까지가 내 한계라 답을 봤다.

  - 다익스트라를 쓰는 것도 있고, DFS + 이분탐색도 있지만 투포인터를 쓰는 알고리즘을 이해하려고 노력했다. 이 문제의 key는 탐색보다는 높이에 있다. 

    1. 우체국의 위치와 집의 갯수를 파악한 후 고도를 vector로 받고 sorting을 한다.

    2. 그리고 unique를 사용해 중복되는 것을 지워준다.

    3. vector의 size만큼 for문을 돌고(i를 이용), v[0]와 v[i]를 포인터로 잡아서 dfs를 돈다. 여기서 v[i]는 고도의 최댓값으로 생각한다.
    4. 집이 있으면 count를 하는 형식으로 8방향을 다 확인하면서 dfs를 돈다
    5. dfs가 끝났을 때 집의 갯수와  값이 같으면 답과 비교해서 update 해준다.

  [문제풀이](<http://wookje.dance/2018/11/19/boj-2842/>)
- 어려웠던 점

  - 투포인터라는 개념을 엄청 기초적인 것만 구현해보고 한동안 안다뤄서 생각도 못하고 있었다.
  - 하나의 알고리즘만 쓰는 것도 못해서 낑낑대는데 지금 더 많이 짬뽕하려니까 미치겠다.
  - 맨날 풀지 못하는 나 자신이 무력해진다. 시무룩...
- 복잡도 $(var): V(size of vector)

  - 시간복잡도:  DFS를 도는데 Vector의 사이즈 만큼 돌음.
  - `O(VN^2)`
