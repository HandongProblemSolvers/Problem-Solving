- **내가 이해한 문제내용**
  - N * N 크기의 맵에 우체국 P와 집 K가 있으며, 각각 높이가 주어진다.
  - 우체국에서 모든 집으로 물건을 배달한 뒤에 우체국으로 돌아오게 된다.
  - 이때 모든집을 배달할때 들린 높이의 최대값과 최솟값의 차를 피로도라 한다.
  - 피로도의 최소값을 구하여라.

- **접근 방식**
  - 일단 문제를 보았을때, 모든 집에 들렸다가, 우체국으로 돌아오는 것을 보고 BFS를 생각했다.
  - 일단 BFS에서 visited와 값을 이용한 이분탐색 형태를 생각했다.
  - 다음 일단 P와 K가 가지는 값은 무조권 포함되어야 한다. 이 조건에서 log^2(V)형태의 이분탐색을 진행했다.
  - 응 틀렸다.
  - 다음 좀 더 고민하는 과정에서 N이 50^2=2500인 점에 주목하였다.
  - 여기서 값에 대해서 탐색이 아니라 가지는 높이의 list들만 탐색해도 된다는 것을 발견했다 ㅇㅁㅇ...
  - 이 뒤에 list들을 unique 한 값만 뽑은 뒤에 sort 한 뒤에 index를 이용해서 이분 탐색했다.

- **어려웠던 점**
  - 처음에 값으로 이분탐색을 하려고 O(Nlog^2_N) 으로 생각했는데, 모순이 있었다...

- **복잡도**
  $(var): E(N * N)
  - 시간복잡도: `O(ElogE)`
  - 공간복잡도: dp에 사용한 메모리 `O(E)`

##### 코드 실행 결과 속도 차이는 아래와 같다.
- BFS(1364ms) < DFS(1336ms) < DFS+이분탐색_최적화(16ms)

### 아래는 DFS와 정렬된 성질을 이용하여 이분탐색을 좀 더 최적화한 코드이다.
```c++
// baekjoon 2842 yechan
#include <cstdio>
#include <cstring>
#include <utility>
#include <algorithm>
#include <vector>
using namespace std;
typedef pair<int, int> P;
const int MAX_N=51;
const int dx[8] = {-1,  0,  1, -1, 0, 1, -1, 1};
const int dy[8] = {-1, -1, -1,  1, 1, 1,  0, 0};

int N, totalNode, nodeCnt, height[MAX_N][MAX_N], sx, sy, ret=1e6;
int num[MAX_N*MAX_N];
vector<int> src;

char board[MAX_N][MAX_N];
bool visited[MAX_N][MAX_N];

void dfs(int x, int y, int bottom, int top) {
	for (int d=0; d<8; d++) {
		int nx = x + dx[d];
		int ny = y + dy[d];
		if (nx < 0 || nx >= N || ny < 0 || ny >= N) continue;
		if (!visited[nx][ny] && bottom <= height[nx][ny] && height[nx][ny] <= top) {
			if (board[nx][ny] == 'K') nodeCnt--;
			visited[nx][ny]=true;
			dfs(nx, ny, bottom, top);
		}
	}
}

bool indfs(int bottom, int top) {
	if (height[sx][sy] < bottom || top < height[sx][sy]) return false;
	memset(visited, 0, sizeof(visited));
	nodeCnt=totalNode;
	visited[sx][sy]=true;
	dfs(sx, sy, bottom, top);
	return nodeCnt==0;
}

int main() {
	scanf("%d", &N);
	for (int i=0; i<N; i++) {
		scanf(" %s", board[i]);
		for (int j=0; j<N; j++) {
			if (board[i][j] == 'P') sx = i, sy = j;
			if (board[i][j] == 'K') totalNode++;
		}
	}

	int k=0;
	for (int i=0; i<N; i++) {
		for (int j=0; j<N; j++) {
			scanf(" %d", &height[i][j]);
			num[k++]=height[i][j];
		}
	}

	sort(num, num+N*N);
	int pv=0;
	for (int i=0; i<N*N; i++) {
		if (pv != num[i]) src.push_back(num[i]);
		pv = num[i];
	}

	int s = 0, e = 0;
	int ch = 0;
	int sSize = src.size();
	while (ch == 0 && s <= e && e < sSize) {
		if (indfs(src[s], src[e])) {
			int ss = s, ee = e;
			while (ss <= ee) {
				int mid = (ss+ee)/2;
				if (indfs(src[mid], src[e])) s = mid, ss = mid+1;
				else ee = mid-1;
			}
		} else {
			int ss = s + 1, ee = sSize - 1;
			ch = 1;
			while (ss <= ee) {
				int mid = (ss+ee)/2;
				if (indfs(src[s], src[mid])) ch = 0, e = mid, ee = mid - 1;
				else ss = mid + 1;
			}
		}
		if (ch == 0) ret = min(ret, src[e] - src[s]);
		s++;
	}
	printf("%d\n", ret);
	return 0;
}
```
