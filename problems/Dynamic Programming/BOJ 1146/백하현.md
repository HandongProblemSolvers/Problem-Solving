- ### 내가 이해한 문제내용  
  - 학생의 수 N(1<=N<=100) 이 주어질 때,   
    
    (1) 1 ~ N 번째 학생으로 갈 수록 키가 커진다.  
    (2) N명의 학생 중 같은 키를 가진 학생은 없다.  
    (3) 맨 앞줄에는 아무 학생이나 올 수 있다.  
    (4) 두번째 줄에는 아무 학생이나 올 수 있다.  
    (5) 세번째 줄부터 N-2번째 줄의 학생보다 N-1번째 줄의 학생이 키가 더 크다면 N번째 줄 학생은 N-1번째 줄의 학생보다 키가 더 작은 학생만 올 수 있다.  
    (6) 세번째 줄부투 N-2번째 줄의 학생보다 N-1번째 줄의 학생이 키가 더 작다면 N번째 줄 학생은 N-1번째 줄의 학생보다 키가 더 큰 학생만 올 수 있다.  
      
    위의 조건을 만족할 때, N명의 학생을 줄세울 수 있는 경우의 수를 1000000으로 나눈 나머지 값 구하기  

- ### 접근방식  
  - dp[i][j][k] : (1 ~ i번 학생이 있고 맨 앞의 학생보다 키가 큰 학생이 j명 있으며 맨 앞의 학생의 상태가 k일 때 줄세울 수 있는 경우의 수)  
    k상태 : (맨앞의 학생이 두번째 학생보다 작을 때 : 0, 두번째 학생보다 클 때 : 1)  
      
  - 문제  
    (1) dp[i][j][k] 업데이트  
          
        j가 0, k가 0일 때,  
        dp[i][j][k] = 0  
          
        else if j가 i-1, k가 1일 때,  
        dp[i][j][k] = 0  
          
        else if k가 0일 때,  
        dp[i][j][k] = (dp[i-1][0][-k+1] + dp[i-1][1][-k+1] + ... + dp[i-1][j-1][-k+1]) % 1000000 
          
        else if k가 1일 때,  
        dp[i][j][k] = (dp[i-1][j][-k+1] + dp[i-1][j+1][-k+1] + ... + dp[i-1][i-2][-k+1]) % 1000000 
    (2) (1)을 2 * (i-1) * N번 반복  
    (3) 구한 경우의 수 % 1000000 출력  
    
- ### 어려웠던 점  
  - dp의 변수를 생각하기 어려웠다.  
    경우의 수를 long long 범위 이내로 만드는 방법을 생각하기 어려웠다.  
    
- ### 복잡도  
  - 시간복잡도 : O(N^2)  
    (2) O(2N^2) = O(N^2)  
        
        
  

    
    
