* **내가 이해한 문제 내용**

  * 3번째 줄부터 이전 줄과 이전하고 이전 줄을 고려하면서 사람수가 채워질 때 설 수 있는 사람의 경우의 수를 모두 구하시오.

* **접근방식**

  * dp로 점화식을 세워 `dp[i][j][k] = 이전하고 이전에 i이고 이전에 j이면서 현재가 k일 때 경우의 수` 로 두었지만 잘못 고려해서 아예 해결 못함

  * [풀이](http://blog.naver.com/PostView.nhn?blogId=pasdfq&logNo=221317287900&parentCategoryNo=&categoryNo=7&viewDate=&isShowPopularPosts=false&from=postView) 를 봤으나 완벽히는 이해하지 못함. 일단 풀이법은 다음과 같다.

  * ```
    dp[i][j][k][0] = i번째 줄의 사람을 결정하는데 왼쪽에 j명이 있고 오른쪽에 k명이 있는 상태에서 더 큰 사람을 골라야 하는 경우일 때의 경우의 수.
    dp[i][j][k][1] = i번째 줄의 사람을 결정하는데 왼쪽에 j명이 있고 오른쪽에 k명이 있는 상태에서 더 작은 사람을 골라야 하는 경우일 때의 경우의 수.
    ```

  * 여기서 오름차순으로 정렬되어있기 때문에 더 큰 사람이란 오른쪽에 있는 사람을 말하며, 더 작은 사람이란 왼쪽에 있는 사람을 말한다.

  * 경우가 항상 왼쪽/오른쪽을 고르는 경우로 나뉘어지기 때문에 각각의 경우에 따라 계산하고 캐싱해주면 된다. 여기서 내가 이해되지 않은 부분은 왼쪽 사람을 골라야 하는 경우에 현재 인덱스 `i` 를 기준으로 어떻게 왼쪽 사람의 수와 오른쪽 사람의 수를 이끌어내느냐이다.

  * 오른쪽을 선택하는 경우에 왼쪽/오른쪽이 어떻게 되는지는 잘 이해가 되지만 **왼쪽도 동일한 원리로 계산될 터인데 그게 잘 맞지가 않는다;;;** 그래도 그 외의 로직은 잘 이해가 된다.

* **어려웠던 점**

  * 너무나도 어려운 것이 여기서 상태값을 통해 점화식을 뽑아내는게 다른 dp에 비해서 난이도가 상당하다. 왼쪽/오른쪽을 생각할 상상조차 하지 못했는데 그게 답이니….
  * 앞으로는 조금 더 넓은 시각으로 빠르게 방향을 바꿔보는게 답인듯 하다...

* **시간복잡도**

  * 위 점화식을 그대로 사용한다면 부분문제의 크기가 `O(N^3)` 이기 때문에 그대로 되지만 풀이에선 `i` 값을 `j` 와 `k` 를 통해서 계산해낼 수 있다고 한다. 그래서 최적화했을 때 `O(N^2)` 까지 줄어든다. 물론 N이 최대 100이라서 `O(N^3)` 도 무난하게 통과한다.