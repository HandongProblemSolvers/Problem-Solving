## 내가 이해한 문제 내용

주어진 문자열 오른쪽에 0개 이상의 문자들을 더해, 그대로 읽으나 거꾸로 읽으나 똑같이 읽히는 문자열(팰린드롬)의 최소 길이 구하기



## 접근 방식

주어진 문자열을 기준으로 순서를 뒤집은 문자열을 새로 만들어 준다. 그 후, 기존 문자열의 꼬리부분과 뒤집은 문자열의 머리부분이 같은 부분이 있는지 검사한다. 그 공통된 부분을 제외한 문자들을 추가로 붙여주면 팰린드롬이 완성된다.



## 어려웠던 점

gcc에서는 char 포인터에 저장한 문자열을 indexing하여도 문제 없이 돌아갔는데, 백준에서는 런타임 에러가 떴다. 문자 길이가 1000자로 제한되어 있으므로 길이가 1000인 char 배열을 선언해 주었더니 그제서야 제대로 돌아가는 것을 확인했다. 런타임 에러가 발생하는 부분을 확인하는데 시간이 조금 걸렸다.



## 복잡도

- 시간복잡도 : 주어진 문자열의 길이를 n이라고 했을 때, 기존 문자열을 한 번 탐색하고 기존 문자열과 뒤집은 문자열을 비교하는 과정이 필요하기 때문에 `O(n^2)` 이다.
- 공간복잡도 : 따로 할당하는 메모리가 없으므로 `O(1)`이다.