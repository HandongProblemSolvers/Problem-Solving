- **내가 이해한 문제내용**
  - 위에서 부터 있는 나사가 있고 숫자는 0 ~ 9가 적혀있다.
  - 나사를 오른쪽으로 돌리면 그 나사만 돌아가지만, 왼쪽으로 돌리면 아래가 모두 돌아간다.
  - 이때 현재 나사 바늘이 주어지면, 맞추고 싶은 나사 바늘로 최소로 움직여 가는 방법을 찾아 출력해라.

- **접근 방식**
  - 일단 문제를 보고 위에서 부터 맞춰가는 형태로 갈 것이라고 짐작할 수 있었다.
  - 일단 문제를 나눠보면 아래와 같다.
  - 1층 부터 N층 까지 나사를 돌리게 된다. 이때 상황을 나눌수 있다.
  $var: k(0 < k <= N) integer ;  (x, y) in k. x and y (0, 9) ;
    - 1) k층이 이미 같은 숫자인경우, 돌리지 않는 것이 최선이다.
    - 2) 만약 k층이 다른 숫자라면, (x != y) if x=3, y=5
    - 2-1) 왼쪽으로 돌리는 경우 (10+3-5) % 10 = 8번 (10+x-y)%10
    - 2-2) 오른쪽으로 돌리는 경우 (10+5-3)%10 = 2번 (10+y-x)%10
    - 3) 이때, 왼쪽으로 돌리는 경우 k+1층에서 돌릴 때에 이미 8번 돌아간 상황이다.
    - 4) 위에서 돌린 만큼 왼쪽으로 돌아간 것으로 x 값을 업데이트 해야함 (x = x - prev_left)
    - 5) 결국 위 식의 형태가 바뀜 최종은 아래와 같이 DP의 subproblem 점화식이 구해짐.
    - 점화식
    - define: int df = (20 + x - y - prev_left) % 10; why 20? (-10 < x-y) and (-10 < -prev_left), so (-20 < x - y - prev_left) @Descript df: remain to left
    - if k == N : return 0
    - else return dp(k)(prev_left) = min(dp(k+1)(**(df+prev_left)%10**) + df, dp(k+1)(prev_left)+(10-df)%10)
  - 위 점화식으로 최소한으로 나사를 돌리는 것은 찾을 수 있다.
  - 여기서 이제 각 위치 나사를 몇번을 돌려야하는지는 BackTracking를 이용하면 간단하게 찾아갈 수 있다.
  - BackTracking은 DP의 성질을 이용한다. 이 성질이란 점화식의 형태를 말하는 것이다.
  - 위 점화식은 **왼쪽으로 돌리는 경우와 오른쪽으로 돌리는 경우**로 나뉘어 진다.
  - 왼쪽으로 돌린 값으로 업데이트 되었다면, **dp(k)(prev_left) == dp(k+1)((df+prev_left)%10) + df** 일 것이며, **이 의미는 k번째 나사는 왼쪽으로 df 번 만큼 돌렸어!** 이다.
  - 오른쪽으로 돌린 값으로 업데이트 되었다면, dp(k)(prev_left) == dp(k+1)(prev_left)+(10-df)%10 일 것이며, **이 의미는 k번째 나사는 오른쪽으로 (10-df)%10 번 만큼 돌렸어!** 이다.
  - 그럼? 안돌렸을때는 ㅎㅎ? df=0이므로 왼쪽이나 오른쪽 둘다 된다.
  - 여기서 정답은 여러가지 라고 했으므로 출력하나 안하나 모두 답이다 ^^?(안하는게 좋긴하것죠?)(난 걍 했다.)(코드 짧은거 조하~)
  - 이렇게 BackTracking를 Recursive하게 하고, base Conditioin은 dp 구한 형태와 같이 k==N일때 return 해주면 Recursion이 정상적으로 작동하게 된다.
  - ㅅㄱ.

- **어려웠던 점**
  - 일단 나사 값이 0 ~ 9 인점을 캐치하여 dp 점화식 유도하는게 처음에 어려웠다.(실수 많이함 ㅠ)
  - 승윤이형이 DP+BackTracking 형태 문제 풀고 싶다고 해서 냈다 ^^ :D

- **복잡도**
  $(var):
  - 시간복잡도: `O(10N) = O(N)`
  - 공간복잡도: `O(N)`
