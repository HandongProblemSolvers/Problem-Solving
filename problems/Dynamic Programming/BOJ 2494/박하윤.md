- 내가 이해한 문제 내용
	- 0-9까지 순서대로 있는 나사 N개가 아래위로 있을 때 왼쪽으로 회전하면 회전시킨 나사보다 아래에 있는 나사도 함께 회전되고 오른쪽으로 회전시킬경우에는 오직 회전 시킨 한개의 나사만 회전하게 된다. 가장 적은 칸 수의 움직임으로 원하는 숫자를 조합시키기 위한 프로그램 

- 입력
	- N, 현재 조합, 원하는 숫자 조합
- 출력
	- 최소 회전 칸수, 각 칸마다 회전한 칸수 (오른쪽으로 이로한 칸수는 -로 표기)

- 접근방식
	- N개의 배열을 만들어야하나..? => 왼쪽 +1, 오른쪽 -1 (0 이하일 경우는 다시 9로) 설정해보기
	- 메모이제이션을 통해 오른쪽, 왼쪽 으로 이동할때의 칸수를 다 저장해놓아서 그 중 min을 찾을까 생각해 보았지만.. 구현을 안해도 일단 경우의 수가 너무 많고 불필요한 연산이 자주 일어나는 거 같아서 다른 방식으로 고민
	- 현재의 숫자 조합과 만들고자 하는 조합의 각 자릿수마다 차이를 계산하여 +면 왼쪽 -면 오른쪽으로 생각하여 if문을 구현하여 계산하기.. => 처음 생각했던 방식보다 범위가 좁혀지긴 한다
	- 왼쪽으로 돌리는게 적은 칸 수의 움직임으로 많은 칸들을 움직일 수 있기 때문에 계산하여 왼쪽으로 옮겨도 원하는 조합이 나올수 있는 경우 왼쪽으로 옮기고 그 다음 한 칸 씩 오른쪽을 움직여서 맞춰보기

*여기까지는 혼자 생각해본 접근방식*

-- 

- 참고한 방법의 접근방식
	- dp 메모이제이션
	- 조합들을 string으로받아서 한 문자열씩 나누고 다시 int 변수로 받아줌
	- 점화식 
		- 오른쪽으로 돌릴 경우: dp(state + 1, add) + 왼쪽 회전수
		- 왼쪽으로 돌릴 경우 : dp(state + 1, (add + 오른쪽 회전수) % 10) + 오른쪽 회전수

- 어려웠던점
	- 아직 구현방법을 생각할 때는 묶어서 보다 각자 따로따로 생각하다 보니 복잡해지고 스스로 헷갈리기도 하다..
	- 결국 구현과정에서 풀이 확인
	- => 점화식을 어떻게 할 지 생각도 못하고 있었다..
	- 다 구현하고 싶었는데.. 너무 피곤해서 못하겠다 ㅠㅠ 나중에 코드 더 자세히 봐야겠다..

- 시간복잡도 : 반복문은 없지만 재귀함수 => O(N)..? 인거 같은데.. 확실히는 모르겠다

[참고자료] <https://healthydeveloper.tistory.com/20>