## BOJ5626 - 제단

- 내가 이해한 문제내용

  - 선택한 범위의 양 끝을 제외한 부분의 높이를 1씩 높이는 데, 주어진 높이의 제단을 쌓는 경우의 수를 구하는 문제.
- 접근 방식

  - 이 문제가 dp임을 알고 들어갔는데 처음에는 어떻게 dp로 접근해야 할지도 감이 안왔다. 경우의 수를 저장하는 것까지는 알겠는데 이 경우의 수가 어디에 영향을 받는지를 정확하게 못찾았다.

  - 답을 보고 접근을 했는데, 항상 바로 앞에 있는 제단을 통해 경우의 수를 저장하면 된다. 항상 제단은 바로 왼쪽의 제단이 1칸 낮을때나 높을때(이 부분이 선택된 경우) 그리고 같이 올라가서 제단의 높이가 같을 때의 경우의 수를 합치면 된다. 이를 식으로 나타내면 이와 같다.

    `dp[n][h] = dp[n-1][h-1] + dp[n-1][h] + dp[n-1][h+1] `

    * 제단의 input은 크게 -1일때와 아닐때로 나눌 수 있다. -1일 경우 정확한 높이를 모르기 때문에 그냥 제단의 모든 높이의 경우의 수를 구해야 하고 input이 -1이 아닐경우에는 그냥 단순히 이전 제단의 (-1, 0, 1)만 구하면 된다. input이 0이면 -1은 제외.

    * 이걸 그대로 배열에다가 하면 메모리 초과가 뜬다. 자세히 살펴보면 필요한 정보는 지금 열과 바로 전의 열만 필요하기 때문에 `N * N`의 배열이 아닌 `N * 2` 의 배열이 필요하게 된다. 이를 이용하는 방법이 `sliding window 알고리즘`이다.
    * 전의 값을 이용해 dp에 계속 저장하고 이를 swap을 통해 바꾼다음 dp 배열을 계속 초기화 해주면 된다.
- 어려웠던 점

  - 아니 근데 지금 내 논리가 뭐가 틀린지 모르겠는데 자꾸 틀렸습니다가 뜬다. 바로 뜨면 또 모르겟는데 76퍼에서 막히니까 답답해 미치겟다. 결국 풀었다! 아니 (N+1)/2로 나누는거 했을 때 잘 안되어서 N/2로 한건데 이걸 `sliding window` 로 바꾸다 보니 바뀐건가 
  - DP를 풀 때마다 점화식을 찾는게 너무 어렵다. 어떻게 저장해야 할지 감이 정말 안온다 흙흙
  - `sliding window`기법을 처음 봤다. 참 별별 방법이 다있음을 느낀다.
- 복잡도

  - 시간복잡도:  `O(n^2)`



틀린 코드... 틀렸기 때문에 Readme의 code에는 X를 해놓겟다.ㅜ

```c++
//BOJ5626 제단
#include <cstdio>
#include <algorithm>
#include <cstring>
using namespace std;
#define MAX_N 10001
#define MOD 1000000007
typedef long long ll;

int N, arr[MAX_N], h;
ll dp[MAX_N], prv[MAX_N];

int main() {
	scanf("%d", &N);
	for (int i = 0; i < N; i++)
		scanf("%d", &arr[i]);
	//처음 input이 1이상일 수도 있음. 그럴 경우는 없으니 0.
	prv[0] = arr[0] <= 0 ? 1 : 0;
	//prv가 이전 열, dp가 현재 열.
    for (int i = 1; i < N; i++) {
		memset(dp, 0, sizeof(dp));
		if (arr[i] == -1) {
			for (int j = 0; j < N / 2; j++) {
				if (j == 0) dp[j] = (prv[0] + prv[1]) % MOD;
				else dp[j] = (prv[j - 1] + prv[j] + prv[j + 1]) % MOD;
			}
		}

		else if (arr[i] == 0)
			dp[0] = (prv[0] + prv[1]) % MOD;

		else {
			h = arr[i];
			dp[h] = (prv[h - 1] + prv[h] + prv[h + 1]) % MOD;
		}
        //넘어가기 전에 바꿔주면서 prv가 update
		swap(prv, dp);
	}
    //prv[0] = dp[0] + dp[1]. 여기서 dp는 바로 앞열의 경우의 수가 저장되어 있음.
	printf("%lld", prv[0]);
	return 0;
}
```

