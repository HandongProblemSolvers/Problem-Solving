**내가 이해한 문제내용**

1. 문제를 보고 제단을 그려봄
<p align="center">
  <img src="https://github.com/hanyoung0411/hanyoungyoo/blob/master/alter.jpg" width="350" alt="alter1">
  <img src="https://github.com/hanyoung0411/hanyoungyoo/blob/master/alter%203.jpg" width="350" alt="alter2t">
</p>
2. 제일 높은 기둥을 중심으로 양옆으로 펼쳐지는 삼각형 모양으로는 필수적으로 있어야하는 부분
3. 전체적으로 보면 제일 높은 기둥을 기준으로 그곳 까지 사다리꼴 모양으로 제단이 쌓일 수 있음
4. 연속적으로 제단이 쌓여야하므로 위로 혹은 옆으로만 제단이 쌓여있을 수 있음
 <hr/>
 
**접근 방식**
1. DP로 해야함. 그래서 점화식을 세우고 제단 기준으로 한 줄씩 넘어가면서 2개의 array에 값을 저장함 
2. 그런데 내 방식으로 하면 중간에 제일 높은 기둥으로 된 곳에서는 array를 다 더해서 result값에 저장해야함.
3. 그러면 시간복잡도가 O(n^3)이 됨
4. 망했습니다.
5. 풀이를 봄.
https://kesakiyo.tistory.com/27 이 분의 코드가 제일 깔끔해서 확인함.

 <hr/>
 
**어려웠던 점**
1. 메모리 초과 / 시간 초과에 대한 것들을 해결하는 것이 어려움.

2. DP에 대한 점화식을 만들고 그 점화식을 실제로 구현하는 것의 어려움.



<hr/>

**개념 정리**

투 포인터  / 슬라이딩 윈도우
투포인터 : 1차원 배열이 있고 각자 다른 원소를 가리키고 있는 2개의 포인터를 조작해가면서 문제를 해결하는 것 

슬라이딩 윈도우: 창문을 한쪽으로 밀면서 문제를 푸는 것과 비슷함

-> 모든 이전 정보가 필요하지는 않다는 것 !
DP를 풀 때 이전 정보가 다 필요한 것은 아니므로 적절하게 필요 없는 부분은 버려가면서
값을 저장해 나가는것을 말한다. 


<hr/>

**복잡도**

시간 복잡도 :  O(N^2)

<hr/>

**피드백**

그림으로 그려서 해보고 있는데, 내 풀이는 1/3만 맞는 경우가 많음. 3일 중에 2일을 내 알고리즘과 구현에 투자하는 데,

1일만 intensive하게 생각하고 나머지 2일을 다른 사람들의 풀이에 대해 생각 하는 것이 더 효율적인 것 같다.
나 혼자 구현하는 것도 좋지만 잘 짜여진 코드를 보고 그 코드를 뜯어 보는 것이 현재는 공부가 더 많이 되는 것 같다. 
