* **내가 이해한 문제 내용**

  * 괄호 문자열의 정의가 주어질 때 길이 n에 대해 k번째 괄호 ㄴㄴ 문자열을 구하시오.

* **접근방식**

  * 계속해서 점화식을 생각했으나 해결하지 못해서 [풀이](https://sgc109.tistory.com/128)를 봄.

  * <u>괄호 문자열의 점화식</u>을 먼저 구해야 함.

  * ```
    dp[i][j] = 문자열의 길이가 i이고 닫히지 못한 열린 괄호의 개수가 j일 때 괄호문자열의 개수
    dp[i][j] = dp[i-1][j-1] + dp[i-1][j+1]
    ```

  * 현재 위치에서 괄호를 닫을수도 있고 열수도 있음

    * 닫는 경우 → 이전에 열린괄호의 개수가 한개 더 많음, 즉 열린괄호의 개수가 줄어든다.
    * 여는 경우 → 이전에 열린괄호의 개수가 한개 더 적음, 즉 열린괄호의 개수가 늘어난다.
    * 단, `dp[i-1][j-1]` 은 여는 경우인데, 이 때 j가 0이하라면 짝이 지어지지 않은 열린괄호의 개수가 0이하라는 것이다. 이 말은 j가 음수가 될 때 닫힌괄호의 개수가 더 많게 되므로 괄호 문자열이 아니게 됨을 뜻한다. 따라서 이 경우를 제외해주어야 한다.
    * 기저사례의 경우는 길이가 `n` 이고 짝이 지어지지 않은 열린괄호의 개수가 0개일 때이다.

  * 이제 <u>괄호 ㄴㄴ 문자열의 점화식</u>을 구해야 한다.

  * ```
    dp[len][open][flag] 
    = 문자열의 길이가 len이고 짝이 지어지지 않은 열린괄호의 개수가 open개이며 중간에서 괄호 ㄴㄴ 문자열의 조건이 	충족된 경우가 있는지에 대한 여부가 flag일 때 괄호 ㄴㄴ 문자열의 개수
    ```

  * 괄호 문자열을 구할 때 제외해주는 경우가 괄호 ㄴㄴ 문자열의 조건을 충족시키므로 예외조건을 없앤다. 이렇게 하면 `open` 이 음수가 될 때가 있기 때문에 애초에 메모이제이션 배열의 크기를 원래 크기의 2배로 설정해 `n` 을 더해준다.

  * 또한 기저사례에 있어서 괄호 문자열일 때와 반대라고 생각할 수 있지만, `)()(` 와 같은 경우를 보면 중간에 닫힌괄호의 개수가 열린괄호의 개수보다 커지는 때가 있다. 그러나 이는 최종적으로 `open=0` 이 되기 때문에 중간에서 괄호 ㄴㄴ 문자열의 조건을 충족하는지 봐야 하는 플래그 값을 추가해야 한다.

  * dp 값을 구한다음 트래킹하면 되는데 이 부분은 도저히 이해가 안됨….나중에 다시 보자..

* **배운점**

  * dp 트래킹의 전형적인 접근방식
    * 일반적인 dp 점화식을 구해서 각 dp 값을 구한다.
    * 구한 dp 값을 이용해 똑같은 논리식으로 트래킹을 하는데 이 때, 대부분 k번째를 구하는 것이므로 k도 재귀함수의 인자로 전달하여 조작해주어야 한다.