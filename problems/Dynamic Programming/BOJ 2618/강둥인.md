# 내가 이해한 문제내용

사건이 발생하면 (1,1), (N, N)에 있는 경찰차가 출동한다.
사건을 순서대로 처리해야 할 때 두 경찰차의 이동거리의 합이 가장 작아지게 경찰차를 배치하는 경우와 그 합을 구하는 문제

# 접근 방식
 - 생각의 흐름: 그리디 알고리즘
  각 사건은 가까운 경찰차가 출동하여 처리한다.
  Ex) (3,5)는 경찰차2가 가까우니 2가 출동하여 처리한다. -> 이동거리: 4
      (5,5)는 경찰차2가 가까우니 2가 출동하여 처리한다. -> 이동거리: 2
      (2,3)은 경찰차1이 가까우니 1이 출동하여 처리한다. -> 이동거리: 3

      -> 문제점: 경찰차1과 경찰차2가 사건지까지 동일한 거리가 나왔을 때, 그 당시에는 어떤 경찰차가 출동하던지 상관없지만 다음 사건에서 이전 사건으로 인해 거리가 늘어날 수 있다. 즉 그리디 알고리즘이 최적의 해를 보장하지 못하는 경우가 생김

      ex) 사건N(3,3), 사건N+1(6,3), 경찰차1(6,3), 경찰차2(3,6) 일 때
      사건 두개를 연달아 봤을 때, 경찰차2가 출동해서 처리하고 경찰차1이 가만히 있는다면 두 사건을 최소비용으로 처리할 수 있다.
      하지만 사건N에서는 어떤 경찰차가 출동하던지 상관없어서 경찰차1이 출동했다고 가정하면, 최소비용이 되지 않는다.


    => DP, BFS
    각 사건까지 최단거리를 기록하면서 반복적으로 돌려보면 구할 수 있을 것이다.
    dp[x][y]을 현재 경찰차가 가장 최근에 처리한 사건이 x,y일때 남은 최소 이동거리로 정의한다면 쉽게 구할 수 있다.

    즉 예시로 설명하면,
    dp[1][2] = 10, 1번 경찰차라고 하자
      그렇다면 1번 경찰차가 사건 1,2를 처리했고 3번 사건을 처리하기 위해선 두가지 경우의 수가 있다.
      dp[3][2] or dp[1][3]
      dp[3][2] = 7, dp[1][3] = 5 라면 3번 사건을 1번 경찰차가 출동해서 처리했음을 알 수 있다.


# 어려웠던 점
  optimal substructure가 있는 것과 최단거리를 보고 DP, DFS를 사용한다고 알아채는데 얼마 걸리진 않았지만 무엇을 DP배열로 사용해야하는지 감을 잡기가 어려웠다.

# 시간복잡도
: O(W^2)
