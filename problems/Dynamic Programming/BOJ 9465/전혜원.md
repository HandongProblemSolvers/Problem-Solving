- **내가 이해한 문제내용**
  - 옆면이 겹치지 않도록 최대한 가격이 높은 스티커를 많이 뜯어낸다.
  
- **접근 방식**
  - 처음에는 greedy 알고리즘을 생각했었는데 완전히 틀린 방식이었다....
  - 어떻게 접근해야할지 고민하다가 DP로 접근해야한다는 것을 알게되었고 base case와 general case를 나눠서 접근했다.
  
- **어려웠던 점**
  - 일단 dp로 풀어야한다는 걸 찾아보고 나서야 알았고, 점화식을 세우고 test case에 대해서는 잘 작동하는데 자꾸 틀렸다고 나온다.
  - 코드를 바꿔서 맞긴 맞았는데 처음에 base case를 다른 사람들보다 더 어렵게 세워서 내가 틀린 부분에 대해서 접근하기 더 어려웠던 것 같다.
  - 메모리 효율을 아껴보겠다고 동적 할당을 했는데 평소보다 메모리 사용량이 훨씬 크게 나와서 좀 당황스러웠다. (이것도 다시 확인해보니까 내가 잘못 코딩했던 거였다..)

- **복잡도**
  - 시간복잡도: 중첩 반복문을 여러분 사용하는데 고정된 숫자 만큼 반복문 도는 것을 빼면  `O(n^2)`
  - 공간복잡도: 이중 어레이를 할당하니까  `O(n^2)`
