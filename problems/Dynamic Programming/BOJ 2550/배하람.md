* **문제 내용**
  * 겹쳐진 전선의 스위치들은 동시에 켤 수 없는 조건에서 동시에 최대로 많이 켤 수 있는 전구의 수와 그에 해당하는 스위치를 오름차순으로 출력하시오.
* **접근 방식**
  * 각 스위치에 대해 겹치는 전선의 개수를 구하여, 오름차순으로 정렬한 뒤 구해보려 했지만 정렬한다 쳐도 전선들간의 관계를 알 수 없기 때문에 불가능했다.
  * 전선 사이의 관계를 알아야 한다는 점 때문에 7578번과는 반대로 이전 스위치들을 켠 적이 있는지에 대한 쿼리를 날렸다. 그 쿼리를 기준으로 동시에 켜는 스위치 개수를 덮어씌우는 방식을 사용했지만 이전에 켰던 스위치들 중에 겹치는 경우가 있을 수 있어서 실패했다.
  * 그래서 겹치는 스위치가 있으면 끄고 새로운 스위치를 켜는 방식으로 수정했지만 처음에 최적해가 나올 경우 덮어씌워지는 문제가 있어서 이 부분도 실패했다.
  * 당연히 이쯤되면 풀이를 봐줘야 하는데 이번엔 특이하게 내가 풀었던 [풀이](https://baeharam.github.io/ps/2019/01/11/ps-boj14003/)를 참고했다. 잊어버린거 실화인가?
  * 다음과 같은 과정으로 이루어진다.
    * **동시에 켜는 전구를 최대로 만들려면 1번째 열을 기준으로 보면서 2번째 열의 인덱스들에 대한 LIS를 구해주면 된다는 관찰이 가장 중요하다.**
    * 이 관찰을 하게 되면 LIS 문제와 그에 대한 추적문제로 환원된다.
    * 기존 LIS는 `lower_bound` 를 활용하면 해결할 수 있지만 추적의 경우라면 따로 **LIS를 관리하는 컨테이너와 그에 대한 인덱스를 저장하는 배열**을 만들어줘야 한다.
    * LIS를 만들 수 있는 경우는 그에 해당하는 인덱스 배열에 저장해주고 LIS 컨테이너를 업데이트 해주는 방식으로 하면 해결할 수 있다.
    * 인덱스 배열을 만든 후에 거꾸로 순회를 해야하는 것이 중요한데, 그 이유는 LIS에 해당하는 각 인덱스들이 점점 증가하긴 하지만 골고루 분포하기 때문에 그렇다. [여기](https://www.crocus.co.kr/681) 를 참고하면 도움이 된다.
* **어려웠던 점 & 배운 점**
  * LIS 문제라는 것을 전혀 눈치채지 못했기 때문에 접근하는 것이 어려웠다.
  * 이걸 세그트리를 통해 해결할 수 있으므로 꼭 세그트리를 이용해서도 구현해봐야 한다.
* **시간복잡도**
  * O(NlgN)