- **내가 이해한 문제내용**
  - 전기줄이 꼬이지 않으면서 킬 수 있는 전구 최대 개수와 눌러야 하는 스위치의 번호

- **접근 방식**
  - 예전에 풀었던 문제이다. 일단 처음에 스위치에 대응 되는 전구의 position를 얻기 위해서 array를 각각 정렬한 뒤에 포지션을 찾았다.
  - 이 뒤에 일단 여기서 최대 선택 가능한 전구수를 얻기 위해서는 2가지 방법이 있다.
  - 처음으로 내가 생각한 방법은 segment Tree로 checking하면서 최대 개수를 새는 방법이다. (전 문제에서 나왔음 BOJ 7578)
  - 다음 이분탐색과 LIS (Longest Increasing Subsequence)를 이용하는 것이다.
  - 이는 **스위치를 최대로 선택하기 위한 조건**이 아래 **스위치의 대응 되는 전구의 position 값을 앞에서 부터 보았을때, LIS중 가장 긴 값을 찾는 것으로 문제를 바꾸어 생각할 수 있음을 파악해야한다.**
  - 위를 이해하고 나서는 최대 길이는 LIS와 이분탐색 형태로 해결이 되는데, LIS 값에 이분탐색으로 자신이 들어갈 수 있는 위치를 찾아서 넣는다. 이는 전에도 이용한 Line Swapping 의 개념상, Top(i) < top(j) 에서 Bottom(i) < bottom(j)를 만족한 경우 꼬이지 않는 점을 착안한다.
  - 이점에서 전에 있던 값보다 크다면 현재 자신의 스위치 위치보다 작은 값에 대해서는 꼬이지 않음을 알 수 있다. 이로써 LIS에 lower_bound를 찾아서 넣어버린다~ (요부분은 설명 잘 못하겠다...ㅋㅋ)
  - 자. 이제 우리는 어떤 스위치를 눌러야 하는지도 알아내야 한다.
  - 이제 재밋는 짓을 할꺼다. LIS값을 업데이트 할때에 trace라는 vector에 LIS position과 전구의 위치 값을 넣어 줄 것이다.
  - 우리가 착안할 점은 **LIS(N) 값은 LIS(N-1)이 채워진 뒤에 채워진다는 전제 조건**이다. 여기서 LIS를 넣는 부분과 업데이트 하는 부분으로 나뉘어 지는데 **우리는 trace에 값에서 N값이 업데이트 되는 전구 값**을 찾은 뒤에 **trace에 값에서 N-1값이 업데이트 되는 전구 값**을 찾는 식으로 문제를 좁혀가면 1 ~ N번째 까지 전구의 위치를 알 수 있다. 예쓰~
  - 자 여기까지 왔다면 다 왔다. 위에서 trace를 이용해서 1 ~ N번째 전구까지 저장이 되어 있을 것이다. (stack or vector 로 저장했다면 N번 부터 1번까지, queue를 이용했다면 1번 부터 N번 까지) 우리는 전구의 위치를 안다면 스위치의 값 또한 다시 알아낼 수 있다. 이렇게 다시 값을 바꿔준 뒤에, 이 값을 sort해서 출력하면 된다~

- **어려웠던 점**
  - LIS 까지는 파악할만 했는데, Trace하는 부분이 감이 왔지만 구현하기가 어려웠다.
  - Array index이 3개이상 되니 해깔린다. 변수의 명확한 명칭과 정의가 중요한 것 같다.

- **복잡도**
  $(var):
  - 시간복잡도: `O(NlogN)`
  - 공간복잡도: `O(N)`
