#내가 이해한 문제 내용
꼬여있는 전선에서 꼬이지 않게 몇 개의 전선 들을 골랐을 때 최대로 고를 수 있는 갯수와 그 경우를 구하기

# 접근방법
- 생각의 흐름
그리디 알고리즘
A, B 배열로 연결정보를 모두 저장한 후
1. B배열의 첫번째 원소 B[0]을 고른다.
2. 그 다음 원소 B[1]을 골랐을 때, A[B[0]] < A[B[1]] 이라면 고르고 count++, 정답 배열에 저장, 그렇지 않다면 그 다음 원소 B[2]를 고른다.
3. 2번 과정을 N번 반복하고 count값을 출력

ans.push_back(B[0]);
for (int i = 1; i < N; i++) {
    if (A[B[i-1]] < A[B[i]]) {
        count++;
        ans.push_back(B[i]);
    }

    else
        continue;
    }

=> 이러면 당연히 안되는데 내가 왜이랬지.. 
위 방법은 바로 전에 있는 전구랑만 비교하기 때문에 예외 케이스가 너무 많다.

- 알고리즘
LIS
핵심:
 스위치를 최대로 선택하기 위한 조건 == 스위치와 대응하는 전구의 position 값을 앞에서 부터 보았을때 LIS중 가장 긴 값을 찾는 것



# 어려웠던 점 및 새로운 알고리즘
그리디.. 멍청이..



# 복잡도
- 시간 복잡도: O(NlogN)
