- ### 내가 이해한 문제내용  
  - 술병의 개수 N(1<=N<=300000), 서랍의 개수 L(1<=N<=300000)이 주어지고 N개의 줄에 서랍의 번호 Ai, Bi가 주어질 때,     
      
    (1) Ai에 술병이 들어갈 수 있다면 Ai에 술병을 저장한다.  
    (2) Bi에 술병이 들어갈 수 있다면 Bi에 술병을 저장한다.  
    (3) Ai에 술병이 있다면 이미 존재하는 술병을 넣을 수 있는 다른 서랍으로 옮긴다. 그곳에도 술병이 있다면 그 술병도 넣을 수 있는 다른 서랍으로 옮긴다.  
    (4) Bi에 술병이 있다면 이미 존재하는 술병을 넣을 수 있는 다른 서랍으로 옮긴다. 그곳에도 술병이 있다면 그 술병도 넣을 수 있는 다른 서랍으로 옮긴다.  
    (5) 서랍의 번호는 1~N 이다.  
      
    위의 조건을 만족할 때, 술병을 저장 가능한지 불가능한지 출력하기  
    
 - ### 접근방식  
  - Disjoint Set: 서로 중복되지 않은 데이터를 저장하는 자료구조  (배열방식, 트리방식)  
    
    make_set: 부모의 노드 번호를 저장하는 p배열에 자신의 노드번호 저장  
    find: 배열을 검사하면서 부모노드의 번호 반환  
    union: 한쪽 부모노드의 p배열 값에 다른 쪽 부모노드의 번호 저장  
    
    Path Compression: find함수에서 재귀적으로 호출하여 부모노드의 번호를 반환하면서 p배열의 값을 업데이트 (시간복잡도를 O(N)에서 O(logN)으로 줄일 수 있다.)  
        
    한쪽 서랍을 방문한다면 그 서랍의 disjoint set에 방문하지 않은 노드가 존재하지 않으므로 다른 쪽 서랍의 disjoint set과 합칠 수 있다.  
    부모노드의 자식 노드들은 방문하지 않은 노드가 존재하지 않으며 부모노드와 연결되어 있으므로 자식노드에서 술병이 이동할 때 술병은 부모노드로 도착할 수 밖에 없다.    
    
  - 문제   
    (1) 서랍의 번호를 저장  
    (2) Disjoint Set 생성  
    (3)     
           
        A서랍을 방문하지 않았을 때,  
        A서랍 방문  
        union(B,A)  
          
        B서랍을 방문하지 않았을 때,   
          
        B서랍 방문  
        union(A,B) 
          
        A서랍의 부모노드를 방문하지 않았을 때,  
          
        A서랍의 부모노드 방문  
        union(B,A)  
          
        B서랍의 부모노드를 방문하지 않았을 때,  
        
        B서랍의 부모노드 방문  
        union(A,B)  
        
        모두 방문했을 때,  
        불가능 출력  
        
        가능 출력  
    (4) (1)~(3)울 N번 반복     
    
- ### 어려웠던 점  
  - Disjoint Set을 문제에 적용시키는 것이 어려웠다.  
    Path Compression을 재귀적으로 만든다는 것을 생각해내기 어려웠다.  
    
 - ### 복잡도  
  - 시간 복잡도: O(MlogN) (M: 술병의 개수, N: 서랍의 개수)  
    (3) O(logN) * (4) O(M) = O(MlogN)  
