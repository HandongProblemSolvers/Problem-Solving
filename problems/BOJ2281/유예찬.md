* **내가 이해한 문제 내용**
  * 맨오른쪽 빈칸의 제곱합을 최소화해라

* **접근방식**
  * 일단 N, M이 1000으로 완전탐색은 아니다
  * 앞에서 그리디 조건은 찾지못했다. Optimal은 반례가 존재.
  * 다음 DP를 생각한다. N이 1000으로 O(N^2)까지 memoizaion 가능함을 안다.
  * state는 뻔하다. dp(idx)(col_pos)임이 보인다. (row 조건은 알 이유가 없다.)
  * 점화식을 짠다. Case는 2개이다.
  * Case1. i번째 사람을 쓰던 자리에 이어서 쓰는 경우 
  *        `dp(i)(col) = dp(i+1)(col + len(str(i)) + 1)`
  * Case2. i번째 사람을 다음줄에 쓰기 시작하는 경우
  *        `dp(i)(col) = dp(i+1)(len(str(i)) + 1) + Square(M-col+1)`
  *        `M - (col-1)` 에서 `col-1`의 의미는 이미 한번 띄어져 있기 때문이다.
  *        `다음줄의 쓰기 조건중 시작 조건인 경우 idx = 0 이므로 이때는 한번 무조건 쓴다.`

* **어려웠던 점**
  * 아직 최적화 못한거 같다. 0초 있음...
  * col도 저장 안하는 방법이 있을것이다 (느낌)
  * 최적화 해보고 올려보겠다.

* **시간복잡도**
  * O(N^2)
