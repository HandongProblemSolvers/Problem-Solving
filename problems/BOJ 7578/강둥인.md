# 내가 이해한 문제
A배열과 B배열을 일대일대응 시켰을 때 생기는 교차점의 갯수 구하기

# 접근 방법
    1. A배열은 식별변호를 차례대로 입력받고 B배열은 map 형식으로 교차점의 갯수(처음엔 모두 0)와 식별번호를 입력받는다.

    2. 식별번호가 같은 배열끼리 이어주며 방문여부를 체크한다.
        예를 들어, A[0] - B[3] 이 이어졌다면, 아직 아무것도 없기 때문에 교차점은 0이 되고 B[3]은 방문상태가 된다.
        그 후, A[1] - B[1]이 이어졌다면, B[1]보다 오른쪽 즉, index가 높은 B[3]이 방문되었기 때문에 교차점이 하나 생긴다. 즉 교차점은 1이 되고 B[1]은 방문 상태가 된다.
        
    3. 이 과정을 반복하면 B[0] ~ B[N]까지 자신보다 오른쪽에 있는 원소 중 방문한 원소의 개수를 알 수 있고 이를 모두 더하면 답이 된다.

    4. 더하는 과정은 세그먼트 트리 알고리즘을 사용한다.

# 어려웠던 점
잘해놓고 마지막 더하는 과정에서 for문 돌려서 n^2이 되어 TLE가 났다. ^.^
세그먼트 트리가 생각이 나지 않았다. 


#복잡도
 - 시간복잡도: O(NlogN)
    N개의 데이터에 대해 구간합을 하는 시간(logN)이 걸리기 때문

 - 공간복잡도: O(N)
    N개의 데이터에 대해 2N개의 배열이 필요함
