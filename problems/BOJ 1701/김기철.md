## BOJ1701 - Cubeditor

- 내가 이해한 문제내용
  - 부분 문자열 중 가장 길이가 긴 문제 (string.length()<=5000)
- 접근 방식
  - 처음 생각은 2번 이상 나오는 가장 긴 문자열을 찾는 것이였다.2번 나오는 문자열 중 가장 길이가 긴 수를 출력하면 끝이라고 생각했으나.
  - 1. 문자열의 길이를 정하는 방법 (첫 문자열은 길이가 5000 2500 1250 625 327... 두 번째 문자열은 길이가 4999 2500 1250 ....이런식으로 하면 height가 log5000 +log4999 + log4998... +log1까지 번의 계산을 해야됐다. log5000!은 끔찍하다.
  - 2. 위 문제만 해결되면 2번 이상 나오는 문자열을 집어넣는 컨테이너를 만들어서 넣었다가 sorting한 가장 긴 length를 반환하면 끝일텐데.. 라고 생각했다.
  - 3. 역시 가장 긴 문자열은 찾는 알고리즘이 존재할꺼다. KMP 가즈아.
  
  - kmp를 돌리는데 정해진 문자열이 없으므로 String s를 1~5000라고 생각하고 kmp를 돌린다.
  - 2번 이상 나온 문자열을 처리한다.
  - 문자열을 찾는데, 그 찾은 문자열이 2번 이상 나오면 max<temp -> max=temp; 해준다.
 
- kmp알고리즘 : Knuth, Morris, Prett 세 사람이 만들어서 kmp란다.. 
  - 알아야 될 것 : 1. prefix(접두사), suffix(접미사), pi배열 이 세가지
  - 접두사 = 문자열 앞에서부터 순서대로 쌓듯이 생각한 것 
  - 접미사 = 문자열 뒤에서부터 순서대로 쌓듯이 생각한 것
  - pi배열 = prefix==suffix의 길이가 최대가 되는 값을 집어넣은 배열.
  - kmp알고리즘 -> 최대로 같았던 길이를 활용해서 접근하는 알고리즘 
  
- 어려웠던 점
  - 분명히 kmp알고리즘을 처음 배웠다. 그런데 풀어야 되는 문제는 1701번이다..
  - 찾고자 하는 문자열이 일단 우리에게는 없다. 가정하는데 이 때 이걸 어떻게 2번 이상 나온 문자열을 처리하는 방법을 잘 모르겠다.
 
- 복잡도
  - 시간복잡도: O(S^2)


[KMP1](https://mygumi.tistory.com/61)
<br>
[KMP2](https://bowbowbow.tistory.com/6)
