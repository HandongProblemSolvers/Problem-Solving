- **내가 이해한 문제내용**
  - N*N 너비에 자동차와 주차장이 있다. 자동차들을 주차장에 주차하고 싶다.
  - 각 주차장에는 하나의 자동차만 주차할 수 있다.
  - 자동차는 1초의 상하좌우 1칸씩 움직일 수 있다.
  - 자동차가 주차하러 갈 때에 자동차가 한칸에 자동차가 2개이상 겹쳐 있는 상황이 가능하다.
  - 이때 모든 자동차를 주차하는데 걸리는 최소의 시간을 출력하라.
  - 주차할 자동차가 없는 경우에는 0을 출력하라.
  - 모든 자동차를 주차할 수 없는 경우에는 -1을 출력하라.

- **접근 방식**
  - 일단 각각의 자동차들에 대해서 주차장 까지의 거리를 BFS를 이용하여 구하였다.
  - 이 뒤에 각 자동차들을 주차장에 넣는 과정속에서 (자동차) <-> (주차장)의 관계가 "이분매칭"의 관계에 있는 걸 알 수 있다.
  - 여기서 이분 매칭 알고리즘에서 추가적인 조건이 존재한다고 생각했다.
  - 일단 조건이 틀렸지만 기술은 하겠다. 조건은 아래와 같다.
    - 조건1. 주차장에 자동차가 있는지 확인한다.
    - 조건2. 주차장의 자동차가 있다면, visited를 확인해서 확인했던 주차장인지에 대해 확인한다.
    - 조건3. 들린적인 없는 경우에는 dfs로 원래 주차되어 있는 자동차를 꺼내서 다음으로 넣을 수 있는지 확인한다.
    - 조건4. 여기서 다음에 넣는 과정에서 다음으로 옮기는 것에 cost와 옮기고 싶어하는 자동차의 cost를 비교해서 cost가 더 작은 쪽으로 선택한다.
  - 이러한 조건을 생각했지만 어떻게 구현할지 애매한 상황이 되어 버렸다.... ㅠ_ㅠ
  - 이러한 과정에서 항상 거리가 고정라는 점에서, 일정 거리 이하인 경우에만 매칭을 하는 형태로 변형시켰다.
  - 일정 거리 이하라는 조건을 저번에 문제에서도 활용한 이분탐색의 형태로 표현하였다.
  - 이분탐색하는 과정에서 모든 자동차가 주차된 경우에는 거리를 줄이고, 아닌 경우는 늘렸다.
  - 마지막까지 ret 값이 정해지지 않은 경우 -1 값을 출력 하고 아닌경우 ret값을 출력하였다.

- **어려웠던 점**
  - 이분매칭의 주차장 선택 조건을 단순화하기 위해 이분탐색을 사용하는데, 이를 생각하는게 어려웠다.

- **복잡도**
  $(var): E(N*N), V(car*car), car=park
  - 시간복잡도: `O(VlogE)`
  - 공간복잡도: dp에 사용한 메모리 `O(V+E)`
